/* tslint:disable */
/* eslint-disable */
/**
 * API Accounts - Open Banking Brasil
 * API de contas de depósito à vista, contas de poupança e contas pré-pagas do Open Banking Brasil – Fase 2. API que retorna informações de contas de depósito à vista, contas de poupança e contas de pagamento pré-pagas mantidas nas instituições transmissoras por seus clientes, incluindo dados de identificação da conta, saldos, limites e transações.\\ Não possui segregação entre pessoa natural e pessoa jurídica.\\ Requer consentimento do cliente para todos os `endpoints`.  # Orientações A `Role`  do diretório de participantes relacionada à presente API é a `DADOS`.\\ Para todos os `endpoints` desta API é previsto o envio de um `token` através do header `Authorization`.\\ Este token deverá estar relacionado ao consentimento (`consentId`) mantido na instituição transmissora dos dados, o qual permitirá a pesquisa e retorno, na API em questão, dos dados relacionados ao `consentId` específico relacionado.\\ Os dados serão devolvidos na consulta desde que o `consentId` relacionado corresponda a um consentimento válido e com o status `AUTHORISED`.\\ É também necessário que o recurso em questão (conta, contrato, etc) esteja disponível na instituição transmissora (ou seja, sem boqueios de qualquer natureza e com todas as autorizações/consentimentos já autorizados).\\ Além disso as `permissions` necessárias deverão ter sido solicitadas quando da criação do consentimento relacionado (`consentId`).\\ Relacionamos a seguir as `permissions` necessárias para a consulta de dados em cada `endpoint` da presente API.  ## Permissions necessárias para a API Accounts  Para cada um dos paths desta API, além dos escopos (`scopes`) indicados existem `permissions` que deverão ser observadas:  ### `/accounts`   - permissions:     - GET: **ACCOUNTS_READ** ### `/accounts/{accountId}`   - permissions:     - GET: **ACCOUNTS_READ** ### `/accounts/{accountId}/balances`   - permissions:     - GET: **ACCOUNTS_BALANCES_READ** ### `/accounts/{accountId}/transactions`   - permissions:     - GET: **ACCOUNTS_TRANSACTIONS_READ** ### `/accounts/{accountId}/overdraft-limits`   - permissions:     - GET: **ACCOUNTS_OVERDRAFT_LIMITS_READ** 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: gt-interfaces@openbankingbr.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga 
 * @export
 * @interface AccountBalancesData
 */
export interface AccountBalancesData {
    /**
     * Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Admite saldo negativo. Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof AccountBalancesData
     */
    availableAmount: number | null;
    /**
     * Moeda referente ao valor do saldo disponível, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountBalancesData
     */
    availableAmountCurrency: string;
    /**
     * Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof AccountBalancesData
     */
    blockedAmount: number | null;
    /**
     * Moeda referente ao valor do saldo bloqueado, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountBalancesData
     */
    blockedAmountCurrency: string;
    /**
     * Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof AccountBalancesData
     */
    automaticallyInvestedAmount: number | null;
    /**
     * Moeda referente ao valor do saldo disponível com aplicação automática, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountBalancesData
     */
    automaticallyInvestedAmountCurrency: string;
}
/**
 * 
 * @export
 * @interface AccountData
 */
export interface AccountData {
    /**
     * Nome da Marca reportada pelo participante do Open Banking. O conceito a que se refere a \'marca\' é em essência uma promessa da empresa em fornecer uma série específica de atributos, benefícios e serviços uniformes aos clientes.
     * @type {string}
     * @memberof AccountData
     */
    brandName: string;
    /**
     * Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
     * @type {string}
     * @memberof AccountData
     */
    companyCnpj: string;
    /**
     * 
     * @type {EnumAccountType}
     * @memberof AccountData
     */
    type: EnumAccountType;
    /**
     * Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
     * @type {string}
     * @memberof AccountData
     */
    compeCode: string;
    /**
     * Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
     * @type {string}
     * @memberof AccountData
     */
    branchCode: string;
    /**
     * Número da conta
     * @type {string}
     * @memberof AccountData
     */
    number: string;
    /**
     * Dígito da conta
     * @type {string}
     * @memberof AccountData
     */
    checkDigit: string;
    /**
     * Identifica de forma única  a conta do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
     * @type {string}
     * @memberof AccountData
     */
    accountId: string;
}
/**
 * Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga 
 * @export
 * @interface AccountIdentificationData
 */
export interface AccountIdentificationData {
    /**
     * Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas). O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe). O campo tem a anotação “n/a” (“não se aplica”) para os participantes do STR aos quais não é atribuído um número-código
     * @type {string}
     * @memberof AccountIdentificationData
     */
    compeCode: string;
    /**
     * Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória) 
     * @type {string}
     * @memberof AccountIdentificationData
     */
    branchCode: string;
    /**
     * Número da conta 
     * @type {string}
     * @memberof AccountIdentificationData
     */
    number: string;
    /**
     * Dígito da conta 
     * @type {string}
     * @memberof AccountIdentificationData
     */
    checkDigit: string;
    /**
     * 
     * @type {EnumAccountType}
     * @memberof AccountIdentificationData
     */
    type: EnumAccountType;
    /**
     * 
     * @type {EnumAccountSubType}
     * @memberof AccountIdentificationData
     */
    subtype: EnumAccountSubType;
    /**
     * Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. \'BRL\' Todos os saldos informados estão representados com a moeda vigente do Brasil 
     * @type {string}
     * @memberof AccountIdentificationData
     */
    currency: string;
}
/**
 * Conjunto de informações da Conta de: depósito à vista 
 * @export
 * @interface AccountOverdraftLimitsData
 */
export interface AccountOverdraftLimitsData {
    /**
     * Valor do limite contratado do cheque especial.
     * @type {number}
     * @memberof AccountOverdraftLimitsData
     */
    overdraftContractedLimit: number | null;
    /**
     * Moeda referente ao valor do limite contratado do cheque especial, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountOverdraftLimitsData
     */
    overdraftContractedLimitCurrency: string;
    /**
     * Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
     * @type {number}
     * @memberof AccountOverdraftLimitsData
     */
    overdraftUsedLimit: number | null;
    /**
     * Moeda referente ao valor utilizado total do limite do cheque especial e o adiantamento a depositante, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountOverdraftLimitsData
     */
    overdraftUsedLimitCurrency: string;
    /**
     * Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
     * @type {number}
     * @memberof AccountOverdraftLimitsData
     */
    unarrangedOverdraftAmount: number | null;
    /**
     * Moeda referente ao valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountOverdraftLimitsData
     */
    unarrangedOverdraftAmountCurrency: string;
}
/**
 * 
 * @export
 * @interface AccountTransactionsData
 */
export interface AccountTransactionsData {
    /**
     * Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
     * @type {string}
     * @memberof AccountTransactionsData
     */
    transactionId?: string;
    /**
     * 
     * @type {EnumCompletedAuthorisedPaymentIndicator}
     * @memberof AccountTransactionsData
     */
    completedAuthorisedPaymentType: EnumCompletedAuthorisedPaymentIndicator;
    /**
     * 
     * @type {EnumCreditDebitIndicator}
     * @memberof AccountTransactionsData
     */
    creditDebitType: EnumCreditDebitIndicator;
    /**
     * Campo livre que corresponde ao identificador da transação na instituição financeira
     * @type {string}
     * @memberof AccountTransactionsData
     */
    transactionName: string;
    /**
     * 
     * @type {EnumTransactionTypes}
     * @memberof AccountTransactionsData
     */
    type: EnumTransactionTypes;
    /**
     * Valor da transação. Expressa em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof AccountTransactionsData
     */
    amount: number;
    /**
     * Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. \'BRL\'.
     * @type {string}
     * @memberof AccountTransactionsData
     */
    transactionCurrency: string;
    /**
     * Se indicador de transação: TRANSACAO_EFETIVADA - corresponde a data de lançamento da transação LANCAMENTO_FUTURO - corresponde a data prevista de efetivação da transação 
     * @type {string}
     * @memberof AccountTransactionsData
     */
    transactionDate: string;
    /**
     * Identificação da pessoa envolvida na transação: pagador ou recebedor (Preencher com o CPF ou CNPJ, sem formatação) 
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieCnpjCpf: string;
    /**
     * 
     * @type {EnumPartiePersonType}
     * @memberof AccountTransactionsData
     */
    partiePersonType: EnumPartiePersonType;
    /**
     * Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas) referente à pessoa envolvida na transação. O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe). O campo tem a anotação “n/a” (“não se aplica”) para os participantes do STR aos quais não é atribuído um número-código
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieCompeCode: string;
    /**
     * Código da Agência detentora da conta da pessoa envolvida na transação. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieBranchCode: string;
    /**
     * Número da conta da pessoa envolvida na transação
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieNumber: string;
    /**
     * Dígito da conta da pessoa envolvida na transação
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieCheckDigit: string;
}
/**
 * Titular, pessoa jurídica a quem se referem os dados que são objeto de compartilhamento.
 * @export
 * @interface BusinessEntity
 */
export interface BusinessEntity {
    /**
     * 
     * @type {BusinessEntityDocument}
     * @memberof BusinessEntity
     */
    document: BusinessEntityDocument;
}
/**
 * 
 * @export
 * @interface BusinessEntityDocument
 */
export interface BusinessEntityDocument {
    /**
     * Número do documento de identificação oficial do titular pessoa jurídica.
     * @type {string}
     * @memberof BusinessEntityDocument
     */
    identification: string;
    /**
     * Tipo do documento de identificação oficial do titular pessoa jurídica.
     * @type {string}
     * @memberof BusinessEntityDocument
     */
    rel: string;
}
/**
 * 
 * @export
 * @interface CreateConsent
 */
export interface CreateConsent {
    /**
     * 
     * @type {CreateConsentData}
     * @memberof CreateConsent
     */
    data: CreateConsentData;
}
/**
 * 
 * @export
 * @interface CreateConsentData
 */
export interface CreateConsentData {
    /**
     * 
     * @type {LoggedUser}
     * @memberof CreateConsentData
     */
    loggedUser: LoggedUser;
    /**
     * 
     * @type {BusinessEntity}
     * @memberof CreateConsentData
     */
    businessEntity?: BusinessEntity;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateConsentData
     */
    permissions: Array<CreateConsentDataPermissionsEnum>;
    /**
     * Data e hora de expiração da permissão. Se não for preenchido, a permissão terá a data aberta. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof CreateConsentData
     */
    expirationDateTime?: string;
    /**
     * Data e hora da transação inicial. Se não for preenchido, a transação terá a data aberta e a data será retornada com a primeira transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof CreateConsentData
     */
    transactionFromDateTime?: string;
    /**
     * Data e hora final da transação. Se não for preenchido, a transação terá a data aberta e a data será retornada com a ultima transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof CreateConsentData
     */
    transactionToDateTime?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateConsentDataPermissionsEnum {
    AccountsRead = 'ACCOUNTS_READ',
    AccountsBalancesRead = 'ACCOUNTS_BALANCES_READ',
    AccountsTransactionsRead = 'ACCOUNTS_TRANSACTIONS_READ',
    AccountsOverdraftLimitsRead = 'ACCOUNTS_OVERDRAFT_LIMITS_READ',
    CreditCardsAccountsRead = 'CREDIT_CARDS_ACCOUNTS_READ',
    CreditCardsAccountsBillsRead = 'CREDIT_CARDS_ACCOUNTS_BILLS_READ',
    CreditCardsAccountsBillsTransactionsRead = 'CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ',
    CreditCardsAccountsLimitsRead = 'CREDIT_CARDS_ACCOUNTS_LIMITS_READ',
    CreditCardsAccountsTransactionsRead = 'CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ',
    CustomersPersonalIdentificationsRead = 'CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ',
    CustomersPersonalAdittionalinfoRead = 'CUSTOMERS_PERSONAL_ADITTIONALINFO_READ',
    CustomersBusinessIdentificationsRead = 'CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ',
    CustomersBusinessAdittionalinfoRead = 'CUSTOMERS_BUSINESS_ADITTIONALINFO_READ',
    FinancingsRead = 'FINANCINGS_READ',
    FinancingsScheduledInstalmentsRead = 'FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    FinancingsPaymentsRead = 'FINANCINGS_PAYMENTS_READ',
    FinancingsWarrantiesRead = 'FINANCINGS_WARRANTIES_READ',
    InvoiceFinancingsRead = 'INVOICE_FINANCINGS_READ',
    InvoiceFinancingsScheduledInstalmentsRead = 'INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    InvoiceFinancingsPaymentsRead = 'INVOICE_FINANCINGS_PAYMENTS_READ',
    InvoiceFinancingsWarrantiesRead = 'INVOICE_FINANCINGS_WARRANTIES_READ',
    LoansRead = 'LOANS_READ',
    LoansScheduledInstalmentsRead = 'LOANS_SCHEDULED_INSTALMENTS_READ',
    LoansPaymentsRead = 'LOANS_PAYMENTS_READ',
    LoansWarrantiesRead = 'LOANS_WARRANTIES_READ',
    UnarrangedAccountsOverdraftRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_READ',
    UnarrangedAccountsOverdraftScheduledInstalmentsRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ',
    UnarrangedAccountsOverdraftPaymentsRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ',
    UnarrangedAccountsOverdraftWarrantiesRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ',
    ResourcesRead = 'RESOURCES_READ'
}

/**
 * Conjunto das informações referentes a lista de faturas associadas à conta de pagamento pós-paga
 * @export
 * @interface CreditCardAccountsBillsData
 */
export interface CreditCardAccountsBillsData {
    /**
     * Informação que identifica a fatura
     * @type {string}
     * @memberof CreditCardAccountsBillsData
     */
    billId: string;
    /**
     * Data de vencimento da Fatura, que aparece para pagamento pelo cliente
     * @type {string}
     * @memberof CreditCardAccountsBillsData
     */
    dueDate: string;
    /**
     * Valor total da fatura
     * @type {number}
     * @memberof CreditCardAccountsBillsData
     */
    billTotalAmount: number;
    /**
     * Moeda referente ao valor de pagamento total da fatura, segundo modelo ISO-4217. p.ex. \'BRL\' Todos os valores informados estão representados com a moeda vigente do Brasil
     * @type {string}
     * @memberof CreditCardAccountsBillsData
     */
    billTotalAmountCurrency: string;
    /**
     * Valor do pagamento minimo da fatura
     * @type {number}
     * @memberof CreditCardAccountsBillsData
     */
    billMinimumAmount: number;
    /**
     * Moeda referente ao valor de pagamento minimo da fatura, segundo modelo ISO-4217. p.ex. \'BRL\' Todos os valores informados estão representados com a moeda vigente do Brasil
     * @type {string}
     * @memberof CreditCardAccountsBillsData
     */
    billMinimumAmountCurrency: string;
    /**
     * Indica se a fatura permite parcelamento (true) ou não (false).
     * @type {boolean}
     * @memberof CreditCardAccountsBillsData
     */
    isInstalment: boolean;
    /**
     * Lista dos encargos cobrados na fatura
     * @type {Array<CreditCardAccountsBillsFinanceCharge>}
     * @memberof CreditCardAccountsBillsData
     */
    financeCharges: Array<CreditCardAccountsBillsFinanceCharge>;
    /**
     * Lista que traz os valores relativos aos pagamentos da Fatura da conta de pagamento pós-paga
     * @type {Array<CreditCardAccountsBillsPayment>}
     * @memberof CreditCardAccountsBillsData
     */
    payments: Array<CreditCardAccountsBillsPayment>;
}
/**
 * 
 * @export
 * @interface CreditCardAccountsBillsFinanceCharge
 */
export interface CreditCardAccountsBillsFinanceCharge {
    /**
     * 
     * @type {EnumCreditCardAccountsFinanceChargeType}
     * @memberof CreditCardAccountsBillsFinanceCharge
     */
    type: EnumCreditCardAccountsFinanceChargeType;
    /**
     * Campo livre, de preenchimento obrigatório se selecionado tipo de encargo \'OUTROS\'
     * @type {string}
     * @memberof CreditCardAccountsBillsFinanceCharge
     */
    additionalInfo?: string;
    /**
     * Valor cobrado pelo encargo. Expresso em valor monetário com 4 casas decimais
     * @type {number}
     * @memberof CreditCardAccountsBillsFinanceCharge
     */
    amount: number | null;
    /**
     * Moeda referente ao valor cobrado pelo encargo, segundo modelo ISO-4217. p.ex. \'BRL\' Todos os saldos informados estão representados com a moeda vigente do Brasil. 
     * @type {string}
     * @memberof CreditCardAccountsBillsFinanceCharge
     */
    currency: string;
}
/**
 * 
 * @export
 * @interface CreditCardAccountsBillsPayment
 */
export interface CreditCardAccountsBillsPayment {
    /**
     * 
     * @type {EnumCreditCardAccountsBillingValueType}
     * @memberof CreditCardAccountsBillsPayment
     */
    valueType: EnumCreditCardAccountsBillingValueType;
    /**
     * Data efetiva de quando o Pagamento da fatura foi realizado
     * @type {string}
     * @memberof CreditCardAccountsBillsPayment
     */
    paymentDate: string;
    /**
     * 
     * @type {EnumCreditCardAccountsPaymentMode}
     * @memberof CreditCardAccountsBillsPayment
     */
    paymentMode: EnumCreditCardAccountsPaymentMode;
    /**
     * Valor pagamento segundo o valueType.  Expresso em valor monetário com 4 casas decimais
     * @type {number}
     * @memberof CreditCardAccountsBillsPayment
     */
    amount: number;
    /**
     * Moeda referente ao valor de pagamento da fatura, segundo modelo ISO-4217. p.ex. \'BRL\' Todos os valores informados estão representados com a moeda vigente do Brasil 
     * @type {string}
     * @memberof CreditCardAccountsBillsPayment
     */
    currency: string;
}
/**
 * Conjunto de informações das Contas de pagamento pós paga
 * @export
 * @interface CreditCardAccountsData
 */
export interface CreditCardAccountsData {
    /**
     * Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
     * @type {string}
     * @memberof CreditCardAccountsData
     */
    creditCardAccountId: string;
    /**
     * Nome da Marca reportada pelo participante do Open Banking. O conceito a que se refere a \'marca\' é em essência uma promessa da empresa em fornecer uma série específica de atributos, benefícios e serviços uniformes aos clientes
     * @type {string}
     * @memberof CreditCardAccountsData
     */
    brandName: string;
    /**
     * Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
     * @type {string}
     * @memberof CreditCardAccountsData
     */
    companyCnpj: string;
    /**
     * Denominação/Identificação do nome da conta de pagamento pós-paga (cartão). Conforme CIRCULAR Nº 3.680,BCB, 2013: \'conta de pagamento pós-paga: destinada à execução de transações de pagamento que independem do aporte prévio de recursos
     * @type {string}
     * @memberof CreditCardAccountsData
     */
    name: string;
    /**
     * 
     * @type {EnumCreditCardAccountsProductType}
     * @memberof CreditCardAccountsData
     */
    productType: EnumCreditCardAccountsProductType;
    /**
     * Informações complementares se tipo de Cartão \'OUTROS\'
     * @type {string}
     * @memberof CreditCardAccountsData
     */
    productAdditionalInfo?: string;
    /**
     * 
     * @type {EnumCreditCardAccountNetwork}
     * @memberof CreditCardAccountsData
     */
    creditCardNetwork: EnumCreditCardAccountNetwork;
    /**
     * Texto livre para especificar categoria de bandeira marcada como \'OUTRAS\'
     * @type {string}
     * @memberof CreditCardAccountsData
     */
    networkAdditionalInfo?: string;
}
/**
 * Conjunto de informações referentes aos limites da conta de pagamento pós-paga.
 * @export
 * @interface CreditCardAccountsLimitsData
 */
export interface CreditCardAccountsLimitsData {
    /**
     * 
     * @type {EnumCreditCardAccountsLineLimitType}
     * @memberof CreditCardAccountsLimitsData
     */
    creditLineLimitType: EnumCreditCardAccountsLineLimitType;
    /**
     * 
     * @type {EnumCreditCardAccountsConsolidationType}
     * @memberof CreditCardAccountsLimitsData
     */
    consolidationType: EnumCreditCardAccountsConsolidationType;
    /**
     * Número de identificação do cartão: corresponde aos 4 últimos dígitos do cartão para PF, ou então, preencher com um identificador para PJ, com as caracteristicas definidas para os IDs no Open Banking. 
     * @type {string}
     * @memberof CreditCardAccountsLimitsData
     */
    identificationNumber: string;
    /**
     * 
     * @type {EnumCreditCardAccountsLineName}
     * @memberof CreditCardAccountsLimitsData
     */
    lineName?: EnumCreditCardAccountsLineName;
    /**
     * Campo de preenchimento obrigatório se selecionada a opção \'OUTRAS\' em lineName.
     * @type {string}
     * @memberof CreditCardAccountsLimitsData
     */
    lineNameAdditionalInfo?: string;
    /**
     * Indica se a operação de crédito é: com limite flexível (true) ou com limite (false).
     * @type {boolean}
     * @memberof CreditCardAccountsLimitsData
     */
    isLimitFlexible: boolean;
    /**
     * Moeda referente ao limite informado, segundo modelo ISO-4217. p.ex. \'BRL.\' Todos os limite informados estão representados com a moeda vigente do do Brasil. 
     * @type {string}
     * @memberof CreditCardAccountsLimitsData
     */
    limitAmountCurrency: string;
    /**
     * Valor total do limite informado Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof CreditCardAccountsLimitsData
     */
    limitAmount: number | null;
    /**
     * Moeda referente ao limite informado, segundo modelo ISO-4217. p.ex. \'BRL.\' Todos os saldos informados estão representados com a moeda vigente do Brasil. 
     * @type {string}
     * @memberof CreditCardAccountsLimitsData
     */
    usedAmountCurrency: string;
    /**
     * Valor utilizado do limite informado Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof CreditCardAccountsLimitsData
     */
    usedAmount: number | null;
    /**
     * Moeda referente ao limite informado, segundo modelo ISO-4217. p.ex. \'BRL.\' Todos os saldos informados estão representados com a moeda vigente do Brasil. 
     * @type {string}
     * @memberof CreditCardAccountsLimitsData
     */
    availableAmountCurrency: string;
    /**
     * Valor disponível do limite informado Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof CreditCardAccountsLimitsData
     */
    availableAmount: number | null;
}
/**
 * Lista que traz os valores relativos aos saldos do Limite de crédito total da conta de pagamento pós-paga
 * @export
 * @interface CreditCardAccountsTransaction
 */
export interface CreditCardAccountsTransaction {
    /**
     * Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    transactionId?: string;
    /**
     * Número de identificação do cartão: corresponde aos 4 últimos dígitos do cartão para PF, ou então, preencher com um identificador para PJ, com as caracteristicas definidas para os IDs no Open Banking. 
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    identificationNumber: string;
    /**
     * 
     * @type {EnumCreditCardAccountsLineName}
     * @memberof CreditCardAccountsTransaction
     */
    lineName?: EnumCreditCardAccountsLineName;
    /**
     * Campo de livre preenchimento. Literal usada na instituição financeira para identificar a transação
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    transactionName: string;
    /**
     * Informação que identifica a fatura onde consta a transação informada.
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    billId?: string;
    /**
     * 
     * @type {EnumCreditDebitIndicator1}
     * @memberof CreditCardAccountsTransaction
     */
    creditDebitType: EnumCreditDebitIndicator1;
    /**
     * 
     * @type {EnumCreditCardTransactionType}
     * @memberof CreditCardAccountsTransaction
     */
    transactionType: EnumCreditCardTransactionType;
    /**
     * Campo livre, de preenchimento obrigatório quando selecionado tipo de transação \"OUTROS\"
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    transactionalAdditionalInfo: string;
    /**
     * 
     * @type {EnumCreditCardAccountsPaymentType}
     * @memberof CreditCardAccountsTransaction
     */
    paymentType: EnumCreditCardAccountsPaymentType;
    /**
     * 
     * @type {EnumCreditCardAccountFee}
     * @memberof CreditCardAccountsTransaction
     */
    feeType: EnumCreditCardAccountFee;
    /**
     * Campo livre, de preenchimento obrigatório quando selecionada tipo de tarifa \"OUTRA\"
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    feeTypeAdditionalInfo: string;
    /**
     * 
     * @type {EnumCreditCardAccountsOtherCreditType}
     * @memberof CreditCardAccountsTransaction
     */
    otherCreditsType: EnumCreditCardAccountsOtherCreditType;
    /**
     * Campo livre, de preenchimento obrigatório quando selecionado tipo de crédito \"OUTROS\"
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    otherCreditsAdditionalInfo: string;
    /**
     * Identificador da parcela que está sendo informada. Campo de livre preenchimento
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    chargeIdentificator: string;
    /**
     * Quantidade de parcelas
     * @type {number}
     * @memberof CreditCardAccountsTransaction
     */
    chargeNumber: number | null;
    /**
     * Valor da transação expresso em valor monetário com 4 casas decimais, em moeda corrente do Brasil
     * @type {number}
     * @memberof CreditCardAccountsTransaction
     */
    brazilianAmount: number | null;
    /**
     * Valor da transação efetuada no exterior e convertida em moeda nacional com 4 casas decimais. Expresso em valor monetário com 4 casas decimais
     * @type {number}
     * @memberof CreditCardAccountsTransaction
     */
    amount: number | null;
    /**
     * Moeda referente ao valor da transação, se a operação foi efetuada em moeda  estrangeira, segundo modelo ISO-4217. Todos os valores informados estão representados com a moeda vigente do Brasil 
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    currency: string;
    /**
     * Data original da transação
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    transactionDate: string;
    /**
     * Data em que a transação foi inserida na fatura
     * @type {string}
     * @memberof CreditCardAccountsTransaction
     */
    billPostDate: string;
    /**
     * O MCC ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades. O MCC é usado para classificar o negócio pelo tipo fornecido de bens ou serviços. Os MCCs são atribuídos por tipo de comerciante (por exemplo, um para hotéis, um para lojas de materiais de escritório, etc.) ou por nome de comerciante (por exemplo, 3000 para a United Airlines). 
     * @type {number}
     * @memberof CreditCardAccountsTransaction
     */
    payeeMCC: number | null;
}
/**
 * Conjunto de informações relativas aos Meios de Pagamento da Conta de pagamento pós-paga
 * @export
 * @interface CreditCardsAccountPaymentMethod
 */
export interface CreditCardsAccountPaymentMethod {
    /**
     * Número de identificação do cartão: corresponde aos 4 últimos dígitos do cartão para pessoa natural, ou então, preencher com um identificador para pessoa jurídica, com as características definidas para os IDs no Open Banking. 
     * @type {string}
     * @memberof CreditCardsAccountPaymentMethod
     */
    identificationNumber: string;
    /**
     * Indica se o Cartão de crédito associado à conta pagamento pós-paga é múltiplo ou não. Cartões denominados múltiplos possuem tanto a função crédito quanto a função débito, devendo o proprietário do cartão, no momento de sua utilização, informar se o pagamento é na função crédito (que leva a um pagamento futuro, por meio de uma fatura do cartão de crédito) ou na função débito. 
     * @type {boolean}
     * @memberof CreditCardsAccountPaymentMethod
     */
    isMultipleCreditCard: boolean;
}
/**
 * Conjunto de informações referentes à identificação da conta de pagamento pós-paga.
 * @export
 * @interface CreditCardsAccountsIdentificationData
 */
export interface CreditCardsAccountsIdentificationData {
    /**
     * Denominação/Identificação do nome da conta de pagamento pós-paga (cartão). Conforme CIRCULAR Nº 3.680,BCB, 2013: \'conta de pagamento pós-paga: destinada à execução de transações de pagamento que independem do aporte prévio de recursos\'. 
     * @type {string}
     * @memberof CreditCardsAccountsIdentificationData
     */
    name: string;
    /**
     * 
     * @type {EnumCreditCardAccountsProductType}
     * @memberof CreditCardsAccountsIdentificationData
     */
    productType: EnumCreditCardAccountsProductType;
    /**
     * Informações complementares se tipo de Cartão \'OUTROS\'
     * @type {string}
     * @memberof CreditCardsAccountsIdentificationData
     */
    productAdditionalInfo?: string;
    /**
     * 
     * @type {EnumCreditCardAccountNetwork}
     * @memberof CreditCardsAccountsIdentificationData
     */
    creditCardNetwork: EnumCreditCardAccountNetwork;
    /**
     * Texto livre para especificar categoria de bandeira marcada como \'OUTRAS\'.
     * @type {string}
     * @memberof CreditCardsAccountsIdentificationData
     */
    networkAdditionalInfo?: string;
    /**
     * 
     * @type {Array<CreditCardsAccountPaymentMethod>}
     * @memberof CreditCardsAccountsIdentificationData
     */
    paymentMethod: Array<CreditCardsAccountPaymentMethod>;
}
/**
 * Subtipo de conta (vide Enum): Conta individual - possui um único titular Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta. Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares 
 * @export
 * @enum {string}
 */
export enum EnumAccountSubType {
    Individual = 'INDIVIDUAL',
    ConjuntaSimples = 'CONJUNTA_SIMPLES',
    ConjuntaSolidaria = 'CONJUNTA_SOLIDARIA'
}

/**
 * Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a \'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados\' 
 * @export
 * @enum {string}
 */
export enum EnumAccountType {
    DepositoAVista = 'CONTA_DEPOSITO_A_VISTA',
    Poupanca = 'CONTA_POUPANCA',
    PagamentoPrePaga = 'CONTA_PAGAMENTO_PRE_PAGA'
}

/**
 * Indicador da transação: - Transação efetivada - Lançamento futuro 
 * @export
 * @enum {string}
 */
export enum EnumCompletedAuthorisedPaymentIndicator {
    TransacaoEfetivada = 'TRANSACAO_EFETIVADA',
    LancamentoFuturo = 'LANCAMENTO_FUTURO'
}

/**
 * Traz os tipos de Tarifas: (Vide Enum) Anuidade, Saque com cartão no Brasil, Saque com cartão no exterior, Avaliação emergencial de crédito, Emissão segunda via, Tarifa pagamento de contas, SMS, OUTRA. [Restrição] Preenchimento obrigatório se Tipo de Transação selecionada for \'TARIFA\' 
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountFee {
    Anuidade = 'ANUIDADE',
    SaqueCartaoBrasil = 'SAQUE_CARTAO_BRASIL',
    SaqueCartaoExterior = 'SAQUE_CARTAO_EXTERIOR',
    AvaliacaoEmergencialCredito = 'AVALIACAO_EMERGENCIAL_CREDITO',
    EmissaoSegundaVia = 'EMISSAO_SEGUNDA_VIA',
    TarifaPagamentoContas = 'TARIFA_PAGAMENTO_CONTAS',
    Sms = 'SMS',
    Outra = 'OUTRA'
}

/**
 * Categoria de Bandeiras de Cartões de Crédito (Instituidor do arranjo de pagamento). Bandeira é a detentora de todos os direitos e deveres da utilização da marca estampada no cartão, inclusive as bandeiras pertencentes aos emissores. 
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountNetwork {
    Visa = 'VISA',
    Mastercard = 'MASTERCARD',
    AmericanExpress = 'AMERICAN_EXPRESS',
    DinersClub = 'DINERS_CLUB',
    Hipercard = 'HIPERCARD',
    BandeiraPropria = 'BANDEIRA_PROPRIA',
    ChequeEletronico = 'CHEQUE_ELETRONICO',
    Elo = 'ELO',
    Outras = 'OUTRAS'
}

/**
 * Traz os tipos dos valores relativos aos pagamentos da fatura da conta de pagamento pós-paga: (Vide Enum)  - Valor de pagamento da fatura com parcelamento  - Valor pagamento da fatura realizado  - Outro Valor pago na fatura 
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsBillingValueType {
    ValorPagamentoFaturaParcelado = 'VALOR_PAGAMENTO_FATURA_PARCELADO',
    ValorPagamentoFaturaRealizado = 'VALOR_PAGAMENTO_FATURA_REALIZADO',
    OutroValorPagoFatura = 'OUTRO_VALOR_PAGO_FATURA'
}

/**
 * Indicador que permite informar se o valor do limite é consolidado ou individual.
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsConsolidationType {
    Consolidado = 'CONSOLIDADO',
    Individual = 'INDIVIDUAL'
}

/**
 * Traz a denominação dos Encargos que incidem na fatura da conta de pagamento pós-paga. (Vide Enum) - Juros remuneratórios por atraso no pagamento da fatura - Multa por atraso no pagamento da fatura - Juros de mora por atraso no pagamento da fatura - IOF - Sem Encargo - Outros 
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsFinanceChargeType {
    JurosRemuneratoriosAtrasoPagamentoFatura = 'JUROS_REMUNERATORIOS_ATRASO_PAGAMENTO_FATURA',
    MultaAtrasoPagamentoFatura = 'MULTA_ATRASO_PAGAMENTO_FATURA',
    JurosMoraAtrasoPagamentoFatura = 'JUROS_MORA_ATRASO_PAGAMENTO_FATURA',
    Iof = 'IOF',
    SemEncargo = 'SEM_ENCARGO',
    Outros = 'OUTROS'
}

/**
 * Indicador do tipo de limite
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsLineLimitType {
    Total = 'LIMITE_CREDITO_TOTAL',
    ModalidadeOperacao = 'LIMITE_CREDITO_MODALIDADE_OPERACAO'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsLineName {
    CreditoAVista = 'CREDITO_A_VISTA',
    CreditoParcelado = 'CREDITO_PARCELADO',
    SaqueCreditoBrasil = 'SAQUE_CREDITO_BRASIL',
    SaqueCreditoExterior = 'SAQUE_CREDITO_EXTERIOR',
    EmprestimoCartaoConsignado = 'EMPRESTIMO_CARTAO_CONSIGNADO',
    Outros = 'OUTROS'
}

/**
 * Traz outros tipos de crédito contratados no cartão. [Restrição] Preenchimento obrigatório se o tipo transação selecionado for \'OPERACOES_CREDITO_CONTRATADAS_CARTAO\' 
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsOtherCreditType {
    CreditoRotativo = 'CREDITO_ROTATIVO',
    ParcelamentoFatura = 'PARCELAMENTO_FATURA',
    Emprestimo = 'EMPRESTIMO',
    Outros = 'OUTROS'
}

/**
 * Traz as formas de efetivação do pagamento realizado: (Vide Enum) - Débito em conta corrente - Boleto bancário - Averbação em folha - PIX 
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsPaymentMode {
    DebitoContaCorrente = 'DEBITO_CONTA_CORRENTE',
    BoletoBancario = 'BOLETO_BANCARIO',
    AverbacaoFolha = 'AVERBACAO_FOLHA',
    Pix = 'PIX'
}

/**
 * Traz os tipos de pagamento. Preenchimento obrigatório se selecionado tipo de transação PAGAMENTO.
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsPaymentType {
    Vista = 'A_VISTA',
    Prazo = 'A_PRAZO'
}

/**
 * Categoria atribuída a um cartão de pagamento, sob uma certa denominação, que lhe agrega um conjunto de vantagens, diferenciando-o de acordo com o perfil do portador.
 * @export
 * @enum {string}
 */
export enum EnumCreditCardAccountsProductType {
    ClassicNacional = 'CLASSIC_NACIONAL',
    ClassicInternacional = 'CLASSIC_INTERNACIONAL',
    Gold = 'GOLD',
    Platinum = 'PLATINUM',
    Infinite = 'INFINITE',
    Electron = 'ELECTRON',
    StandardNacional = 'STANDARD_NACIONAL',
    StandardInternacional = 'STANDARD_INTERNACIONAL',
    Eletronic = 'ELETRONIC',
    Black = 'BLACK',
    Redeshop = 'REDESHOP',
    MaestroMastercardMaestro = 'MAESTRO_MASTERCARD_MAESTRO',
    Green = 'GREEN',
    Blue = 'BLUE',
    Bluebox = 'BLUEBOX',
    ProfissionalLiberal = 'PROFISSIONAL_LIBERAL',
    ChequeEletronico = 'CHEQUE_ELETRONICO',
    Corporativo = 'CORPORATIVO',
    Empresarial = 'EMPRESARIAL',
    Compras = 'COMPRAS',
    BasicoNacional = 'BASICO_NACIONAL',
    BasicoInternacional = 'BASICO_INTERNACIONAL',
    Nanquim = 'NANQUIM',
    Grafite = 'GRAFITE',
    Mais = 'MAIS',
    Outros = 'OUTROS'
}

/**
 * Traz os tipos de Transação
 * @export
 * @enum {string}
 */
export enum EnumCreditCardTransactionType {
    Pagamento = 'PAGAMENTO',
    Tarifa = 'TARIFA',
    OperacoesCreditoContratadasCartao = 'OPERACOES_CREDITO_CONTRATADAS_CARTAO',
    Estorno = 'ESTORNO',
    Cashback = 'CASHBACK',
    Outros = 'OUTROS'
}

/**
 * Indicador do tipo de lançamento: Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente. Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente. 
 * @export
 * @enum {string}
 */
export enum EnumCreditDebitIndicator {
    Credito = 'CREDITO',
    Debito = 'DEBITO'
}

/**
 * Indicador do tipo de lançamento: Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente. Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente. 
 * @export
 * @enum {string}
 */
export enum EnumCreditDebitIndicator1 {
    Credito = 'CREDITO',
    Debito = 'DEBITO'
}

/**
 * Identificação do Tipo de Pessoa da pessoa envolvida na transação. Pessoa Natural - Informar CPF no campo “payerCnpjCpf” Pessoa Jurídica - Informar CNPJ no campo “payerCnpjCpf” 
 * @export
 * @enum {string}
 */
export enum EnumPartiePersonType {
    Natural = 'PESSOA_NATURAL',
    Juridica = 'PESSOA_JURIDICA'
}

/**
 * Tipo de Transação 
 * @export
 * @enum {string}
 */
export enum EnumTransactionTypes {
    Ted = 'TED',
    Doc = 'DOC',
    Pix = 'PIX',
    TransferenciaMesmaInstituicao = 'TRANSFERENCIA_MESMA_INSTITUICAO',
    Boleto = 'BOLETO',
    ConvenioArrecadacao = 'CONVENIO_ARRECADACAO',
    PacoteTarifaServicos = 'PACOTE_TARIFA_SERVICOS',
    TarifaServicosAvulsos = 'TARIFA_SERVICOS_AVULSOS',
    FolhaPagamento = 'FOLHA_PAGAMENTO',
    Deposito = 'DEPOSITO',
    Saque = 'SAQUE',
    Cartao = 'CARTAO',
    EncargosJurosChequeEspecial = 'ENCARGOS_JUROS_CHEQUE_ESPECIAL',
    RendimentoAplicFinanceira = 'RENDIMENTO_APLIC_FINANCEIRA',
    PortabilidadeSalario = 'PORTABILIDADE_SALARIO',
    ResgateAplicFinanceira = 'RESGATE_APLIC_FINANCEIRA',
    OperacaoCredito = 'OPERACAO_CREDITO',
    Outros = 'OUTROS'
}

/**
 * 
 * @export
 * @interface Introspection
 */
export interface Introspection {
    /**
     * if the token has expired
     * @type {boolean}
     * @memberof Introspection
     */
    active?: boolean;
    /**
     * id of client who owns the token
     * @type {string}
     * @memberof Introspection
     */
    client_id?: string;
    /**
     * expiration time in ms
     * @type {string}
     * @memberof Introspection
     */
    exp?: string;
    /**
     * when the token was issued
     * @type {string}
     * @memberof Introspection
     */
    iat?: string;
    /**
     * the issuer
     * @type {string}
     * @memberof Introspection
     */
    iss?: string;
    /**
     * unique string
     * @type {string}
     * @memberof Introspection
     */
    jti?: string;
    /**
     * scope
     * @type {string}
     * @memberof Introspection
     */
    scope?: string;
    /**
     * type of token
     * @type {string}
     * @memberof Introspection
     */
    token_type?: string;
    /**
     * subject of token (not always present, depending on the token)
     * @type {string}
     * @memberof Introspection
     */
    sub?: string;
}
/**
 * 
 * @export
 * @interface IntrospectionRequest
 */
export interface IntrospectionRequest {
    /**
     * Oauth 2.0 token to be introspected
     * @type {string}
     * @memberof IntrospectionRequest
     */
    token: string;
}
/**
 * Referências para outros recusos da API requisitada.
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * URI completo que gerou a resposta atual.
     * @type {string}
     * @memberof Links
     */
    self: string;
    /**
     * URI da primeira página que originou essa lista de resultados. Restrição - Obrigatório quando não for a primeira página da resposta
     * @type {string}
     * @memberof Links
     */
    first?: string;
    /**
     * URI da página anterior dessa lista de resultados. Restrição -  Obrigatório quando não for a primeira página da resposta
     * @type {string}
     * @memberof Links
     */
    prev?: string;
    /**
     * URI da próxima página dessa lista de resultados. Restrição - Obrigatório quando não for a última página da resposta
     * @type {string}
     * @memberof Links
     */
    next?: string;
    /**
     * URI da última página dessa lista de resultados. Restrição - Obrigatório quando não for a última página da resposta
     * @type {string}
     * @memberof Links
     */
    last?: string;
}
/**
 * Usuário (pessoa natural) que encontra-se logado na instituição receptora e que iniciará o processo de consentimento para compartilhamento de dados.
 * @export
 * @interface LoggedUser
 */
export interface LoggedUser {
    /**
     * 
     * @type {LoggedUserDocument}
     * @memberof LoggedUser
     */
    document: LoggedUserDocument;
}
/**
 * 
 * @export
 * @interface LoggedUserDocument
 */
export interface LoggedUserDocument {
    /**
     * Número do documento de identificação oficial do usuário.
     * @type {string}
     * @memberof LoggedUserDocument
     */
    identification: string;
    /**
     * Tipo do documento de identificação oficial do usuário.
     * @type {string}
     * @memberof LoggedUserDocument
     */
    rel: string;
}
/**
 * Meta informações referente a API requisitada.
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * Número total de registros no resultado
     * @type {number}
     * @memberof Meta
     */
    totalRecords: number;
    /**
     * Número total de páginas no resultado
     * @type {number}
     * @memberof Meta
     */
    totalPages: number;
    /**
     * Data e hora da consulta, conforme especificação RFC-3339, formato UTC.
     * @type {string}
     * @memberof Meta
     */
    requestDateTime: string;
}
/**
 * 
 * @export
 * @interface ResponseAccountBalances
 */
export interface ResponseAccountBalances {
    /**
     * 
     * @type {AccountBalancesData}
     * @memberof ResponseAccountBalances
     */
    data: AccountBalancesData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountBalances
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountBalances
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseAccountIdentification
 */
export interface ResponseAccountIdentification {
    /**
     * 
     * @type {AccountIdentificationData}
     * @memberof ResponseAccountIdentification
     */
    data: AccountIdentificationData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountIdentification
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountIdentification
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseAccountList
 */
export interface ResponseAccountList {
    /**
     * Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
     * @type {Array<AccountData>}
     * @memberof ResponseAccountList
     */
    data: Array<AccountData>;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountList
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountList
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseAccountOverdraftLimits
 */
export interface ResponseAccountOverdraftLimits {
    /**
     * 
     * @type {AccountOverdraftLimitsData}
     * @memberof ResponseAccountOverdraftLimits
     */
    data: AccountOverdraftLimitsData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountOverdraftLimits
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountOverdraftLimits
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseAccountTransactions
 */
export interface ResponseAccountTransactions {
    /**
     * Lista dos lançamentos referentes às transações realizadas e de lançamentos futuros para as contas de: depósito à vista, poupança e de pagamento pré-paga 
     * @type {Array<AccountTransactionsData>}
     * @memberof ResponseAccountTransactions
     */
    data: Array<AccountTransactionsData>;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountTransactions
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountTransactions
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseConsent
 */
export interface ResponseConsent {
    /**
     * 
     * @type {ResponseConsentData}
     * @memberof ResponseConsent
     */
    data: ResponseConsentData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseConsent
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseConsent
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface ResponseConsentData
 */
export interface ResponseConsentData {
    /**
     * Identificador único do consentimento.
     * @type {string}
     * @memberof ResponseConsentData
     */
    consentId: string;
    /**
     * Data e hora em que o recurso foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentData
     */
    creationDateTime: string;
    /**
     * Estado atual do consentimento cadastrado.
     * @type {string}
     * @memberof ResponseConsentData
     */
    status: ResponseConsentDataStatusEnum;
    /**
     * Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentData
     */
    statusUpdateDateTime: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentData
     */
    permissions: Array<ResponseConsentDataPermissionsEnum>;
    /**
     * Data e hora de expiração da permissão. Se não for preenchido, a permissão terá a data aberta. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentData
     */
    expirationDateTime?: string;
    /**
     * Data e hora da transação inicial. Se não for preenchido, a transação terá a data aberta e a data será retornada com a primeira transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentData
     */
    transactionFromDateTime?: string;
    /**
     * Data e hora final da transação. Se não for preenchido, a transação terá a data aberta e a data será retornada com a ultima transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentData
     */
    transactionToDateTime?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ResponseConsentDataStatusEnum {
    Authorised = 'AUTHORISED',
    AwaitingAuthorisation = 'AWAITING_AUTHORISATION',
    Rejected = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum ResponseConsentDataPermissionsEnum {
    AccountsRead = 'ACCOUNTS_READ',
    AccountsBalancesRead = 'ACCOUNTS_BALANCES_READ',
    AccountsTransactionsRead = 'ACCOUNTS_TRANSACTIONS_READ',
    AccountsOverdraftLimitsRead = 'ACCOUNTS_OVERDRAFT_LIMITS_READ',
    CreditCardsAccountsRead = 'CREDIT_CARDS_ACCOUNTS_READ',
    CreditCardsAccountsBillsRead = 'CREDIT_CARDS_ACCOUNTS_BILLS_READ',
    CreditCardsAccountsBillsTransactionsRead = 'CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ',
    CreditCardsAccountsLimitsRead = 'CREDIT_CARDS_ACCOUNTS_LIMITS_READ',
    CreditCardsAccountsTransactionsRead = 'CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ',
    CustomersPersonalIdentificationsRead = 'CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ',
    CustomersPersonalAdittionalinfoRead = 'CUSTOMERS_PERSONAL_ADITTIONALINFO_READ',
    CustomersBusinessIdentificationsRead = 'CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ',
    CustomersBusinessAdittionalinfoRead = 'CUSTOMERS_BUSINESS_ADITTIONALINFO_READ',
    FinancingsRead = 'FINANCINGS_READ',
    FinancingsScheduledInstalmentsRead = 'FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    FinancingsPaymentsRead = 'FINANCINGS_PAYMENTS_READ',
    FinancingsWarrantiesRead = 'FINANCINGS_WARRANTIES_READ',
    InvoiceFinancingsRead = 'INVOICE_FINANCINGS_READ',
    InvoiceFinancingsScheduledInstalmentsRead = 'INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    InvoiceFinancingsPaymentsRead = 'INVOICE_FINANCINGS_PAYMENTS_READ',
    InvoiceFinancingsWarrantiesRead = 'INVOICE_FINANCINGS_WARRANTIES_READ',
    LoansRead = 'LOANS_READ',
    LoansScheduledInstalmentsRead = 'LOANS_SCHEDULED_INSTALMENTS_READ',
    LoansPaymentsRead = 'LOANS_PAYMENTS_READ',
    LoansWarrantiesRead = 'LOANS_WARRANTIES_READ',
    UnarrangedAccountsOverdraftRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_READ',
    UnarrangedAccountsOverdraftScheduledInstalmentsRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ',
    UnarrangedAccountsOverdraftPaymentsRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ',
    UnarrangedAccountsOverdraftWarrantiesRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ',
    ResourcesRead = 'RESOURCES_READ'
}

/**
 * 
 * @export
 * @interface ResponseConsentFull
 */
export interface ResponseConsentFull {
    /**
     * 
     * @type {ResponseConsentFullData}
     * @memberof ResponseConsentFull
     */
    data: ResponseConsentFullData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseConsentFull
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseConsentFull
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface ResponseConsentFullData
 */
export interface ResponseConsentFullData {
    /**
     * Identificador único do consentimento.
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    consentId: string;
    /**
     * OpenID Subject of the Authenitcating User
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    sub?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentFullData
     */
    linkedAccountIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentFullData
     */
    linkedCreditCardAccountIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentFullData
     */
    linkedLoanAccountIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentFullData
     */
    linkedFinancingAccountIds?: Array<string>;
    /**
     * Identification of the client that made the request.
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    clientId: string;
    /**
     * Data e hora em que o recurso foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    creationDateTime: string;
    /**
     * Estado atual do consentimento cadastrado.
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    status: ResponseConsentFullDataStatusEnum;
    /**
     * Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    statusUpdateDateTime: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentFullData
     */
    permissions: Array<ResponseConsentFullDataPermissionsEnum>;
    /**
     * Data e hora de expiração da permissão. Se não for preenchido, a permissão terá a data aberta. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    expirationDateTime?: string;
    /**
     * Data e hora da transação inicial. Se não for preenchido, a transação terá a data aberta e a data será retornada com a primeira transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    transactionFromDateTime?: string;
    /**
     * Data e hora final da transação. Se não for preenchido, a transação terá a data aberta e a data será retornada com a ultima transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    transactionToDateTime?: string;
    /**
     * 
     * @type {LoggedUser}
     * @memberof ResponseConsentFullData
     */
    loggedUser: LoggedUser;
    /**
     * 
     * @type {BusinessEntity}
     * @memberof ResponseConsentFullData
     */
    businessEntity?: BusinessEntity;
}

/**
    * @export
    * @enum {string}
    */
export enum ResponseConsentFullDataStatusEnum {
    Authorised = 'AUTHORISED',
    AwaitingAuthorisation = 'AWAITING_AUTHORISATION',
    Rejected = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum ResponseConsentFullDataPermissionsEnum {
    AccountsRead = 'ACCOUNTS_READ',
    AccountsBalancesRead = 'ACCOUNTS_BALANCES_READ',
    AccountsTransactionsRead = 'ACCOUNTS_TRANSACTIONS_READ',
    AccountsOverdraftLimitsRead = 'ACCOUNTS_OVERDRAFT_LIMITS_READ',
    CreditCardsAccountsRead = 'CREDIT_CARDS_ACCOUNTS_READ',
    CreditCardsAccountsBillsRead = 'CREDIT_CARDS_ACCOUNTS_BILLS_READ',
    CreditCardsAccountsBillsTransactionsRead = 'CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ',
    CreditCardsAccountsLimitsRead = 'CREDIT_CARDS_ACCOUNTS_LIMITS_READ',
    CreditCardsAccountsTransactionsRead = 'CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ',
    CustomersPersonalIdentificationsRead = 'CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ',
    CustomersPersonalAdittionalinfoRead = 'CUSTOMERS_PERSONAL_ADITTIONALINFO_READ',
    CustomersBusinessIdentificationsRead = 'CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ',
    CustomersBusinessAdittionalinfoRead = 'CUSTOMERS_BUSINESS_ADITTIONALINFO_READ',
    FinancingsRead = 'FINANCINGS_READ',
    FinancingsScheduledInstalmentsRead = 'FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    FinancingsPaymentsRead = 'FINANCINGS_PAYMENTS_READ',
    FinancingsWarrantiesRead = 'FINANCINGS_WARRANTIES_READ',
    InvoiceFinancingsRead = 'INVOICE_FINANCINGS_READ',
    InvoiceFinancingsScheduledInstalmentsRead = 'INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    InvoiceFinancingsPaymentsRead = 'INVOICE_FINANCINGS_PAYMENTS_READ',
    InvoiceFinancingsWarrantiesRead = 'INVOICE_FINANCINGS_WARRANTIES_READ',
    LoansRead = 'LOANS_READ',
    LoansScheduledInstalmentsRead = 'LOANS_SCHEDULED_INSTALMENTS_READ',
    LoansPaymentsRead = 'LOANS_PAYMENTS_READ',
    LoansWarrantiesRead = 'LOANS_WARRANTIES_READ',
    UnarrangedAccountsOverdraftRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_READ',
    UnarrangedAccountsOverdraftScheduledInstalmentsRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ',
    UnarrangedAccountsOverdraftPaymentsRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ',
    UnarrangedAccountsOverdraftWarrantiesRead = 'UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ',
    ResourcesRead = 'RESOURCES_READ'
}

/**
 * 
 * @export
 * @interface ResponseCreditCardAccountsBills
 */
export interface ResponseCreditCardAccountsBills {
    /**
     * 
     * @type {Array<CreditCardAccountsBillsData>}
     * @memberof ResponseCreditCardAccountsBills
     */
    data: Array<CreditCardAccountsBillsData>;
    /**
     * 
     * @type {Links}
     * @memberof ResponseCreditCardAccountsBills
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseCreditCardAccountsBills
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseCreditCardAccountsIdentification
 */
export interface ResponseCreditCardAccountsIdentification {
    /**
     * 
     * @type {CreditCardsAccountsIdentificationData}
     * @memberof ResponseCreditCardAccountsIdentification
     */
    data: CreditCardsAccountsIdentificationData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseCreditCardAccountsIdentification
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseCreditCardAccountsIdentification
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseCreditCardAccountsLimits
 */
export interface ResponseCreditCardAccountsLimits {
    /**
     * 
     * @type {Array<CreditCardAccountsLimitsData>}
     * @memberof ResponseCreditCardAccountsLimits
     */
    data: Array<CreditCardAccountsLimitsData>;
    /**
     * 
     * @type {Links}
     * @memberof ResponseCreditCardAccountsLimits
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseCreditCardAccountsLimits
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseCreditCardAccountsList
 */
export interface ResponseCreditCardAccountsList {
    /**
     * Conjunto de informações de conta de pagamento pós-paga
     * @type {Array<CreditCardAccountsData>}
     * @memberof ResponseCreditCardAccountsList
     */
    data: Array<CreditCardAccountsData>;
    /**
     * 
     * @type {Links}
     * @memberof ResponseCreditCardAccountsList
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseCreditCardAccountsList
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseCreditCardAccountsTransactions
 */
export interface ResponseCreditCardAccountsTransactions {
    /**
     * 
     * @type {Array<CreditCardAccountsTransaction>}
     * @memberof ResponseCreditCardAccountsTransactions
     */
    data: Array<CreditCardAccountsTransaction>;
    /**
     * 
     * @type {Links}
     * @memberof ResponseCreditCardAccountsTransactions
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseCreditCardAccountsTransactions
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseError
 */
export interface ResponseError {
    /**
     * 
     * @type {Array<ResponseErrorErrors>}
     * @memberof ResponseError
     */
    errors: Array<ResponseErrorErrors>;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseError
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface ResponseErrorErrors
 */
export interface ResponseErrorErrors {
    /**
     * Código de erro específico do endpoint
     * @type {string}
     * @memberof ResponseErrorErrors
     */
    code: string;
    /**
     * Título legível por humanos deste erro específico
     * @type {string}
     * @memberof ResponseErrorErrors
     */
    title: string;
    /**
     * Descrição legível por humanos deste erro específico
     * @type {string}
     * @memberof ResponseErrorErrors
     */
    detail: string;
}
/**
 * 
 * @export
 * @interface UpdateConsent
 */
export interface UpdateConsent {
    /**
     * 
     * @type {UpdateConsentData}
     * @memberof UpdateConsent
     */
    data: UpdateConsentData;
}
/**
 * 
 * @export
 * @interface UpdateConsentData
 */
export interface UpdateConsentData {
    /**
     * Estado atual do consentimento cadastrado.
     * @type {string}
     * @memberof UpdateConsentData
     */
    status?: UpdateConsentDataStatusEnum;
    /**
     * OpenID Subject of the Authenitcating User
     * @type {string}
     * @memberof UpdateConsentData
     */
    sub?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateConsentData
     */
    linkedAccountIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateConsentData
     */
    linkedCreditCardAccountIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateConsentData
     */
    linkedLoanAccountIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateConsentData
     */
    linkedFinancingAccountIds?: Array<string>;
    /**
     * Identification of the client that made the request.
     * @type {string}
     * @memberof UpdateConsentData
     */
    clientId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateConsentDataStatusEnum {
    Authorised = 'AUTHORISED',
    AwaitingAuthorisation = 'AWAITING_AUTHORISATION',
    Rejected = 'REJECTED'
}


/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, accountType?: EnumAccountType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAccounts', 'authorization', authorization)
            const localVarPath = `/accounts/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountId: async (authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAccountsAccountId', 'authorization', authorization)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountsAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/v1/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdBalances: async (authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAccountsAccountIdBalances', 'authorization', authorization)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountsAccountIdBalances', 'accountId', accountId)
            const localVarPath = `/accounts/v1/accounts/{accountId}/balances`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdOverdraftLimits: async (authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAccountsAccountIdOverdraftLimits', 'authorization', authorization)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountsAccountIdOverdraftLimits', 'accountId', accountId)
            const localVarPath = `/accounts/v1/accounts/{accountId}/overdraft-limits`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdTransactions: async (authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromBookingDate?: string, toBookingDate?: string, creditDebitIndicator?: EnumCreditDebitIndicator, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAccountsAccountIdTransactions', 'authorization', authorization)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountsAccountIdTransactions', 'accountId', accountId)
            const localVarPath = `/accounts/v1/accounts/{accountId}/transactions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (fromBookingDate !== undefined) {
                localVarQueryParameter['fromBookingDate'] = (fromBookingDate as any instanceof Date) ?
                    (fromBookingDate as any).toISOString().substr(0,10) :
                    fromBookingDate;
            }

            if (toBookingDate !== undefined) {
                localVarQueryParameter['toBookingDate'] = (toBookingDate as any instanceof Date) ?
                    (toBookingDate as any).toISOString().substr(0,10) :
                    toBookingDate;
            }

            if (creditDebitIndicator !== undefined) {
                localVarQueryParameter['creditDebitIndicator'] = creditDebitIndicator;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, accountType?: EnumAccountType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsAccountId(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountIdentification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsAccountIdBalances(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountBalances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsAccountIdOverdraftLimits(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountOverdraftLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsAccountIdTransactions(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromBookingDate?: string, toBookingDate?: string, creditDebitIndicator?: EnumCreditDebitIndicator, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountTransactions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, accountType?: EnumAccountType, options?: any): AxiosPromise<ResponseAccountList> {
            return localVarFp.getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountId(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountIdentification> {
            return localVarFp.getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdBalances(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountBalances> {
            return localVarFp.getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdOverdraftLimits(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountOverdraftLimits> {
            return localVarFp.getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdTransactions(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromBookingDate?: string, toBookingDate?: string, creditDebitIndicator?: EnumCreditDebitIndicator, options?: any): AxiosPromise<ResponseAccountTransactions> {
            return localVarFp.getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
     * @summary Obtém a lista de contas consentidas pelo cliente.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, accountType?: EnumAccountType, options?: any) {
        return AccountsApiFp(this.configuration).getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsAccountId(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os saldos da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsAccountIdBalances(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os limites da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsAccountIdOverdraftLimits(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de transações da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromBookingDate] Data inicial de filtragem.
     * @param {string} [toBookingDate] Data final de filtragem.
     * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsAccountIdTransactions(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromBookingDate?: string, toBookingDate?: string, creditDebitIndicator?: EnumCreditDebitIndicator, options?: any) {
        return AccountsApiFp(this.configuration).getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConsentsApi - axios parameter creator
 * @export
 */
export const ConsentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsDeleteConsentsConsentId: async (consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('consentsDeleteConsentsConsentId', 'consentId', consentId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('consentsDeleteConsentsConsentId', 'authorization', authorization)
            const localVarPath = `/consents/v1/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", ["consents"], configuration)

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsGetConsentsConsentId: async (consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('consentsGetConsentsConsentId', 'consentId', consentId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('consentsGetConsentsConsentId', 'authorization', authorization)
            const localVarPath = `/consents/v1/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", ["consents"], configuration)

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPostConsents: async (authorization: string, createConsent: CreateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('consentsPostConsents', 'authorization', authorization)
            // verify required parameter 'createConsent' is not null or undefined
            assertParamExists('consentsPostConsents', 'createConsent', createConsent)
            const localVarPath = `/consents/v1/consents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", ["consents"], configuration)

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConsent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPutConsents: async (consentId: string, authorization: string, updateConsent: UpdateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('consentsPutConsents', 'consentId', consentId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('consentsPutConsents', 'authorization', authorization)
            // verify required parameter 'updateConsent' is not null or undefined
            assertParamExists('consentsPutConsents', 'updateConsent', updateConsent)
            const localVarPath = `/consents/v1/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", ["consents"], configuration)

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConsent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsentsApi - functional programming interface
 * @export
 */
export const ConsentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consentsDeleteConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consentsGetConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseConsent | ResponseConsentFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consentsPostConsents(authorization: string, createConsent: CreateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseConsent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consentsPutConsents(consentId: string, authorization: string, updateConsent: UpdateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseConsentFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConsentsApi - factory interface
 * @export
 */
export const ConsentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsentsApiFp(configuration)
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsDeleteConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<void> {
            return localVarFp.consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsGetConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseConsent | ResponseConsentFull> {
            return localVarFp.consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPostConsents(authorization: string, createConsent: CreateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseConsent> {
            return localVarFp.consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPutConsents(consentId: string, authorization: string, updateConsent: UpdateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseConsentFull> {
            return localVarFp.consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConsentsApi - object-oriented interface
 * @export
 * @class ConsentsApi
 * @extends {BaseAPI}
 */
export class ConsentsApi extends BaseAPI {
    /**
     * Método para deletar/revogar o consentimento identificado por consentId.
     * @summary Deletar/revogar o consentimento identificado por consentId.
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public consentsDeleteConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ConsentsApiFp(this.configuration).consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter detalhes do consentimento identificado por consentId.
     * @summary Obter detalhes do consentimento identificado por consentId.
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public consentsGetConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ConsentsApiFp(this.configuration).consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para a criação de um novo consentimento.
     * @summary Criar novo pedido de consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {CreateConsent} createConsent Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public consentsPostConsents(authorization: string, createConsent: CreateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ConsentsApiFp(this.configuration).consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para a criação de um novo consentimento.
     * @summary Update the consent API
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public consentsPutConsents(consentId: string, authorization: string, updateConsent: UpdateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ConsentsApiFp(this.configuration).consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditCardApi - axios parameter creator
 * @export
 */
export const CreditCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Método para obter a lista de contas de pagamento pós-paga mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
         * @summary Conjunto de informações das Contas de pagamento pós paga
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccounts: async (authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('creditCardsGetAccounts', 'authorization', authorization)
            const localVarPath = `/credit-cards-accounts/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountId: async (authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountId', 'authorization', authorization)
            // verify required parameter 'creditCardAccountId' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountId', 'creditCardAccountId', creditCardAccountId)
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter a lista de faturas da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de faturas da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromDueDate] Data inicial de filtragem.
         * @param {string} [toDueDate] Data final de filtragem.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBills: async (authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromDueDate?: string, toDueDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdBills', 'authorization', authorization)
            // verify required parameter 'creditCardAccountId' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdBills', 'creditCardAccountId', creditCardAccountId)
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}/bills`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (fromDueDate !== undefined) {
                localVarQueryParameter['fromDueDate'] = (fromDueDate as any instanceof Date) ?
                    (fromDueDate as any).toISOString().substr(0,10) :
                    fromDueDate;
            }

            if (toDueDate !== undefined) {
                localVarQueryParameter['toDueDate'] = (toDueDate as any instanceof Date) ?
                    (toDueDate as any).toISOString().substr(0,10) :
                    toDueDate;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId e billId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId e billId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} billId Identificador da fatura.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions: async (authorization: string, creditCardAccountId: string, billId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromTransactionDate?: string, toTransactionDate?: string, transactionType?: EnumCreditCardTransactionType, payeeMCC?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions', 'authorization', authorization)
            // verify required parameter 'creditCardAccountId' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions', 'creditCardAccountId', creditCardAccountId)
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions', 'billId', billId)
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}/bills/{billId}/transactions`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)))
                .replace(`{${"billId"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (fromTransactionDate !== undefined) {
                localVarQueryParameter['fromTransactionDate'] = (fromTransactionDate as any instanceof Date) ?
                    (fromTransactionDate as any).toISOString().substr(0,10) :
                    fromTransactionDate;
            }

            if (toTransactionDate !== undefined) {
                localVarQueryParameter['toTransactionDate'] = (toTransactionDate as any instanceof Date) ?
                    (toTransactionDate as any).toISOString().substr(0,10) :
                    toTransactionDate;
            }

            if (transactionType !== undefined) {
                localVarQueryParameter['transactionType'] = transactionType;
            }

            if (payeeMCC !== undefined) {
                localVarQueryParameter['payeeMCC'] = payeeMCC;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os limites da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora. 
         * @summary Obtém os limites da conta identificada por creditCardAccountId. 
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdLimits: async (authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdLimits', 'authorization', authorization)
            // verify required parameter 'creditCardAccountId' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdLimits', 'creditCardAccountId', creditCardAccountId)
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}/limits`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdTransactions: async (authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromTransactionDate?: string, toTransactionDate?: string, transactionType?: EnumCreditCardTransactionType, payeeMCC?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdTransactions', 'authorization', authorization)
            // verify required parameter 'creditCardAccountId' is not null or undefined
            assertParamExists('creditCardsGetAccountsCreditCardAccountIdTransactions', 'creditCardAccountId', creditCardAccountId)
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}/transactions`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (fromTransactionDate !== undefined) {
                localVarQueryParameter['fromTransactionDate'] = (fromTransactionDate as any instanceof Date) ?
                    (fromTransactionDate as any).toISOString().substr(0,10) :
                    fromTransactionDate;
            }

            if (toTransactionDate !== undefined) {
                localVarQueryParameter['toTransactionDate'] = (toTransactionDate as any instanceof Date) ?
                    (toTransactionDate as any).toISOString().substr(0,10) :
                    toTransactionDate;
            }

            if (transactionType !== undefined) {
                localVarQueryParameter['transactionType'] = transactionType;
            }

            if (payeeMCC !== undefined) {
                localVarQueryParameter['payeeMCC'] = payeeMCC;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditCardApi - functional programming interface
 * @export
 */
export const CreditCardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditCardApiAxiosParamCreator(configuration)
    return {
        /**
         * Método para obter a lista de contas de pagamento pós-paga mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
         * @summary Conjunto de informações das Contas de pagamento pós paga
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditCardsGetAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreditCardAccountsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os dados de identificação da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditCardsGetAccountsCreditCardAccountId(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreditCardAccountsIdentification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter a lista de faturas da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de faturas da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromDueDate] Data inicial de filtragem.
         * @param {string} [toDueDate] Data final de filtragem.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditCardsGetAccountsCreditCardAccountIdBills(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromDueDate?: string, toDueDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreditCardAccountsBills>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId e billId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId e billId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} billId Identificador da fatura.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization: string, creditCardAccountId: string, billId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromTransactionDate?: string, toTransactionDate?: string, transactionType?: EnumCreditCardTransactionType, payeeMCC?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreditCardAccountsTransactions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os limites da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora. 
         * @summary Obtém os limites da conta identificada por creditCardAccountId. 
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditCardsGetAccountsCreditCardAccountIdLimits(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreditCardAccountsLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditCardsGetAccountsCreditCardAccountIdTransactions(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromTransactionDate?: string, toTransactionDate?: string, transactionType?: EnumCreditCardTransactionType, payeeMCC?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreditCardAccountsTransactions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditCardApi - factory interface
 * @export
 */
export const CreditCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditCardApiFp(configuration)
    return {
        /**
         * Método para obter a lista de contas de pagamento pós-paga mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
         * @summary Conjunto de informações das Contas de pagamento pós paga
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<ResponseCreditCardAccountsList> {
            return localVarFp.creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountId(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseCreditCardAccountsIdentification> {
            return localVarFp.creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter a lista de faturas da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de faturas da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromDueDate] Data inicial de filtragem.
         * @param {string} [toDueDate] Data final de filtragem.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBills(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromDueDate?: string, toDueDate?: string, options?: any): AxiosPromise<ResponseCreditCardAccountsBills> {
            return localVarFp.creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId e billId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId e billId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} billId Identificador da fatura.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization: string, creditCardAccountId: string, billId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromTransactionDate?: string, toTransactionDate?: string, transactionType?: EnumCreditCardTransactionType, payeeMCC?: number, options?: any): AxiosPromise<ResponseCreditCardAccountsTransactions> {
            return localVarFp.creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os limites da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora. 
         * @summary Obtém os limites da conta identificada por creditCardAccountId. 
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdLimits(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseCreditCardAccountsLimits> {
            return localVarFp.creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdTransactions(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromTransactionDate?: string, toTransactionDate?: string, transactionType?: EnumCreditCardTransactionType, payeeMCC?: number, options?: any): AxiosPromise<ResponseCreditCardAccountsTransactions> {
            return localVarFp.creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditCardApi - object-oriented interface
 * @export
 * @class CreditCardApi
 * @extends {BaseAPI}
 */
export class CreditCardApi extends BaseAPI {
    /**
     * Método para obter a lista de contas de pagamento pós-paga mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
     * @summary Conjunto de informações das Contas de pagamento pós paga
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    public creditCardsGetAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, options?: any) {
        return CreditCardApiFp(this.configuration).creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os dados de identificação da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por creditCardAccountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    public creditCardsGetAccountsCreditCardAccountId(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter a lista de faturas da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de faturas da conta identificada por creditCardAccountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromDueDate] Data inicial de filtragem.
     * @param {string} [toDueDate] Data final de filtragem.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    public creditCardsGetAccountsCreditCardAccountIdBills(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromDueDate?: string, toDueDate?: string, options?: any) {
        return CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId e billId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de transações da conta identificada por creditCardAccountId e billId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} billId Identificador da fatura.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromTransactionDate] Data inicial de filtragem.
     * @param {string} [toTransactionDate] Data final de filtragem.
     * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
     * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    public creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization: string, creditCardAccountId: string, billId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromTransactionDate?: string, toTransactionDate?: string, transactionType?: EnumCreditCardTransactionType, payeeMCC?: number, options?: any) {
        return CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os limites da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora. 
     * @summary Obtém os limites da conta identificada por creditCardAccountId. 
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    public creditCardsGetAccountsCreditCardAccountIdLimits(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de transações da conta identificada por creditCardAccountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromTransactionDate] Data inicial de filtragem.
     * @param {string} [toTransactionDate] Data final de filtragem.
     * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
     * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    public creditCardsGetAccountsCreditCardAccountIdTransactions(authorization: string, creditCardAccountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromTransactionDate?: string, toTransactionDate?: string, transactionType?: EnumCreditCardTransactionType, payeeMCC?: number, options?: any) {
        return CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpenIDProviderApi - axios parameter creator
 * @export
 */
export const OpenIDProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backchannelPost: async (xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/backchannel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAuthPost: async (xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/device/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet: async (xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdDelete: async (clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('regClientIdDelete', 'clientId', clientId)
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdGet: async (clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('regClientIdGet', 'clientId', clientId)
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdPut: async (clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('regClientIdPut', 'clientId', clientId)
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regPost: async (xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPost: async (xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenIntrospectionPost: async (xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/introspection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: async (introspectionRequest: IntrospectionRequest, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'introspectionRequest' is not null or undefined
            assertParamExists('tokenPost', 'introspectionRequest', introspectionRequest)
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenIDProviderApi - functional programming interface
 * @export
 */
export const OpenIDProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenIDProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backchannelPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceAuthPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meGet(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regClientIdDelete(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regClientIdGet(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regClientIdPut(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenIntrospectionPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPost(introspectionRequest: IntrospectionRequest, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpenIDProviderApi - factory interface
 * @export
 */
export const OpenIDProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenIDProviderApiFp(configuration)
    return {
        /**
         * 
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backchannelPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return localVarFp.backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAuthPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return localVarFp.deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return localVarFp.meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdDelete(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return localVarFp.regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdGet(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return localVarFp.regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdPut(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return localVarFp.regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return localVarFp.regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return localVarFp.requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenIntrospectionPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return localVarFp.tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(introspectionRequest: IntrospectionRequest, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return localVarFp.tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenIDProviderApi - object-oriented interface
 * @export
 * @class OpenIDProviderApi
 * @extends {BaseAPI}
 */
export class OpenIDProviderApi extends BaseAPI {
    /**
     * 
     * @summary Post a Oauth 2.0 ciba request
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public backchannelPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post a request to the device endpoint to retrieve a token
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public deviceAuthPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the user information stored in OpenId Provider
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public meGet(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an oauth client. Cascade delete all child details
     * @param {string} clientId The ClientId to be deleted
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public regClientIdDelete(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an oauth client by Id
     * @param {string} clientId The oauth ClientId
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public regClientIdGet(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an oauth client by Id
     * @param {string} clientId The oauth ClientId
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public regClientIdPut(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a client
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public regPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post a Oauth 2.0 pushed authorization request
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public requestPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public tokenIntrospectionPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post a request to the token endpoint to retrieve a token
     * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public tokenPost(introspectionRequest: IntrospectionRequest, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccounts: async (authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserAccounts', 'authorization', authorization)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAccounts', 'userId', userId)
            const localVarPath = `/user/{userId}/accounts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditCardAccounts: async (authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserCreditCardAccounts', 'authorization', authorization)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserCreditCardAccounts', 'userId', userId)
            const localVarPath = `/user/{userId}/credit-card-accounts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFinancings: async (authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserFinancings', 'authorization', authorization)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserFinancings', 'userId', userId)
            const localVarPath = `/user/{userId}/financings`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInvoiceFinancings: async (authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserInvoiceFinancings', 'authorization', authorization)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserInvoiceFinancings', 'userId', userId)
            const localVarPath = `/user/{userId}/invoice-financings`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLoans: async (authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserLoans', 'authorization', authorization)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserLoans', 'userId', userId)
            const localVarPath = `/user/{userId}/loans`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUnarrangedAccountsOverdraft: async (authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserUnarrangedAccountsOverdraft', 'authorization', authorization)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserUnarrangedAccountsOverdraft', 'userId', userId)
            const localVarPath = `/user/{userId}/unarranged-accounts-overdraft`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorizer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccounts(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCreditCardAccounts(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreditCardAccountsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFinancings(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInvoiceFinancings(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserLoans(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUnarrangedAccountsOverdraft(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccounts(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountList> {
            return localVarFp.getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditCardAccounts(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseCreditCardAccountsList> {
            return localVarFp.getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFinancings(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountList> {
            return localVarFp.getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInvoiceFinancings(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountList> {
            return localVarFp.getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLoans(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountList> {
            return localVarFp.getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUnarrangedAccountsOverdraft(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountList> {
            return localVarFp.getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAccounts(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserCreditCardAccounts(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserFinancings(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserInvoiceFinancings(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserLoans(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserUnarrangedAccountsOverdraft(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
}


