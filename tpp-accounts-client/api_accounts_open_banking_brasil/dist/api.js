"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * API Accounts - Open Banking Brasil
 * API de contas de depósito à vista, contas de poupança e contas pré-pagas do Open Banking Brasil – Fase 2. API que retorna informações de contas de depósito à vista, contas de poupança e contas de pagamento pré-pagas mantidas nas instituições transmissoras por seus clientes, incluindo dados de identificação da conta, saldos, limites e transações.\\ Não possui segregação entre pessoa natural e pessoa jurídica.\\ Requer consentimento do cliente para todos os `endpoints`.  # Orientações A `Role`  do diretório de participantes relacionada à presente API é a `DADOS`.\\ Para todos os `endpoints` desta API é previsto o envio de um `token` através do header `Authorization`.\\ Este token deverá estar relacionado ao consentimento (`consentId`) mantido na instituição transmissora dos dados, o qual permitirá a pesquisa e retorno, na API em questão, dos dados relacionados ao `consentId` específico relacionado.\\ Os dados serão devolvidos na consulta desde que o `consentId` relacionado corresponda a um consentimento válido e com o status `AUTHORISED`.\\ É também necessário que o recurso em questão (conta, contrato, etc) esteja disponível na instituição transmissora (ou seja, sem boqueios de qualquer natureza e com todas as autorizações/consentimentos já autorizados).\\ Além disso as `permissions` necessárias deverão ter sido solicitadas quando da criação do consentimento relacionado (`consentId`).\\ Relacionamos a seguir as `permissions` necessárias para a consulta de dados em cada `endpoint` da presente API.  ## Permissions necessárias para a API Accounts  Para cada um dos paths desta API, além dos escopos (`scopes`) indicados existem `permissions` que deverão ser observadas:  ### `/accounts`   - permissions:     - GET: **ACCOUNTS_READ** ### `/accounts/{accountId}`   - permissions:     - GET: **ACCOUNTS_READ** ### `/accounts/{accountId}/balances`   - permissions:     - GET: **ACCOUNTS_BALANCES_READ** ### `/accounts/{accountId}/transactions`   - permissions:     - GET: **ACCOUNTS_TRANSACTIONS_READ** ### `/accounts/{accountId}/overdraft-limits`   - permissions:     - GET: **ACCOUNTS_OVERDRAFT_LIMITS_READ**
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: gt-interfaces@openbankingbr.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.OpenIDProviderApi = exports.OpenIDProviderApiFactory = exports.OpenIDProviderApiFp = exports.OpenIDProviderApiAxiosParamCreator = exports.CreditCardApi = exports.CreditCardApiFactory = exports.CreditCardApiFp = exports.CreditCardApiAxiosParamCreator = exports.ConsentsApi = exports.ConsentsApiFactory = exports.ConsentsApiFp = exports.ConsentsApiAxiosParamCreator = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.UpdateConsentDataStatusEnum = exports.ResponseConsentFullDataPermissionsEnum = exports.ResponseConsentFullDataStatusEnum = exports.ResponseConsentDataPermissionsEnum = exports.ResponseConsentDataStatusEnum = exports.EnumTransactionTypes = exports.EnumPartiePersonType = exports.EnumCreditDebitIndicator1 = exports.EnumCreditDebitIndicator = exports.EnumCreditCardTransactionType = exports.EnumCreditCardAccountsProductType = exports.EnumCreditCardAccountsPaymentType = exports.EnumCreditCardAccountsPaymentMode = exports.EnumCreditCardAccountsOtherCreditType = exports.EnumCreditCardAccountsLineName = exports.EnumCreditCardAccountsLineLimitType = exports.EnumCreditCardAccountsFinanceChargeType = exports.EnumCreditCardAccountsConsolidationType = exports.EnumCreditCardAccountsBillingValueType = exports.EnumCreditCardAccountNetwork = exports.EnumCreditCardAccountFee = exports.EnumCompletedAuthorisedPaymentIndicator = exports.EnumAccountType = exports.EnumAccountSubType = exports.CreateConsentDataPermissionsEnum = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var CreateConsentDataPermissionsEnum;
(function (CreateConsentDataPermissionsEnum) {
    CreateConsentDataPermissionsEnum["AccountsRead"] = "ACCOUNTS_READ";
    CreateConsentDataPermissionsEnum["AccountsBalancesRead"] = "ACCOUNTS_BALANCES_READ";
    CreateConsentDataPermissionsEnum["AccountsTransactionsRead"] = "ACCOUNTS_TRANSACTIONS_READ";
    CreateConsentDataPermissionsEnum["AccountsOverdraftLimitsRead"] = "ACCOUNTS_OVERDRAFT_LIMITS_READ";
    CreateConsentDataPermissionsEnum["CreditCardsAccountsRead"] = "CREDIT_CARDS_ACCOUNTS_READ";
    CreateConsentDataPermissionsEnum["CreditCardsAccountsBillsRead"] = "CREDIT_CARDS_ACCOUNTS_BILLS_READ";
    CreateConsentDataPermissionsEnum["CreditCardsAccountsBillsTransactionsRead"] = "CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ";
    CreateConsentDataPermissionsEnum["CreditCardsAccountsLimitsRead"] = "CREDIT_CARDS_ACCOUNTS_LIMITS_READ";
    CreateConsentDataPermissionsEnum["CreditCardsAccountsTransactionsRead"] = "CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ";
    CreateConsentDataPermissionsEnum["CustomersPersonalIdentificationsRead"] = "CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ";
    CreateConsentDataPermissionsEnum["CustomersPersonalAdittionalinfoRead"] = "CUSTOMERS_PERSONAL_ADITTIONALINFO_READ";
    CreateConsentDataPermissionsEnum["CustomersBusinessIdentificationsRead"] = "CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ";
    CreateConsentDataPermissionsEnum["CustomersBusinessAdittionalinfoRead"] = "CUSTOMERS_BUSINESS_ADITTIONALINFO_READ";
    CreateConsentDataPermissionsEnum["FinancingsRead"] = "FINANCINGS_READ";
    CreateConsentDataPermissionsEnum["FinancingsScheduledInstalmentsRead"] = "FINANCINGS_SCHEDULED_INSTALMENTS_READ";
    CreateConsentDataPermissionsEnum["FinancingsPaymentsRead"] = "FINANCINGS_PAYMENTS_READ";
    CreateConsentDataPermissionsEnum["FinancingsWarrantiesRead"] = "FINANCINGS_WARRANTIES_READ";
    CreateConsentDataPermissionsEnum["InvoiceFinancingsRead"] = "INVOICE_FINANCINGS_READ";
    CreateConsentDataPermissionsEnum["InvoiceFinancingsScheduledInstalmentsRead"] = "INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ";
    CreateConsentDataPermissionsEnum["InvoiceFinancingsPaymentsRead"] = "INVOICE_FINANCINGS_PAYMENTS_READ";
    CreateConsentDataPermissionsEnum["InvoiceFinancingsWarrantiesRead"] = "INVOICE_FINANCINGS_WARRANTIES_READ";
    CreateConsentDataPermissionsEnum["LoansRead"] = "LOANS_READ";
    CreateConsentDataPermissionsEnum["LoansScheduledInstalmentsRead"] = "LOANS_SCHEDULED_INSTALMENTS_READ";
    CreateConsentDataPermissionsEnum["LoansPaymentsRead"] = "LOANS_PAYMENTS_READ";
    CreateConsentDataPermissionsEnum["LoansWarrantiesRead"] = "LOANS_WARRANTIES_READ";
    CreateConsentDataPermissionsEnum["UnarrangedAccountsOverdraftRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_READ";
    CreateConsentDataPermissionsEnum["UnarrangedAccountsOverdraftScheduledInstalmentsRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ";
    CreateConsentDataPermissionsEnum["UnarrangedAccountsOverdraftPaymentsRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ";
    CreateConsentDataPermissionsEnum["UnarrangedAccountsOverdraftWarrantiesRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ";
    CreateConsentDataPermissionsEnum["ResourcesRead"] = "RESOURCES_READ";
})(CreateConsentDataPermissionsEnum = exports.CreateConsentDataPermissionsEnum || (exports.CreateConsentDataPermissionsEnum = {}));
/**
 * Subtipo de conta (vide Enum): Conta individual - possui um único titular Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta. Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
 * @export
 * @enum {string}
 */
var EnumAccountSubType;
(function (EnumAccountSubType) {
    EnumAccountSubType["Individual"] = "INDIVIDUAL";
    EnumAccountSubType["ConjuntaSimples"] = "CONJUNTA_SIMPLES";
    EnumAccountSubType["ConjuntaSolidaria"] = "CONJUNTA_SOLIDARIA";
})(EnumAccountSubType = exports.EnumAccountSubType || (exports.EnumAccountSubType = {}));
/**
 * Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a \'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados\'
 * @export
 * @enum {string}
 */
var EnumAccountType;
(function (EnumAccountType) {
    EnumAccountType["DepositoAVista"] = "CONTA_DEPOSITO_A_VISTA";
    EnumAccountType["Poupanca"] = "CONTA_POUPANCA";
    EnumAccountType["PagamentoPrePaga"] = "CONTA_PAGAMENTO_PRE_PAGA";
})(EnumAccountType = exports.EnumAccountType || (exports.EnumAccountType = {}));
/**
 * Indicador da transação: - Transação efetivada - Lançamento futuro
 * @export
 * @enum {string}
 */
var EnumCompletedAuthorisedPaymentIndicator;
(function (EnumCompletedAuthorisedPaymentIndicator) {
    EnumCompletedAuthorisedPaymentIndicator["TransacaoEfetivada"] = "TRANSACAO_EFETIVADA";
    EnumCompletedAuthorisedPaymentIndicator["LancamentoFuturo"] = "LANCAMENTO_FUTURO";
})(EnumCompletedAuthorisedPaymentIndicator = exports.EnumCompletedAuthorisedPaymentIndicator || (exports.EnumCompletedAuthorisedPaymentIndicator = {}));
/**
 * Traz os tipos de Tarifas: (Vide Enum) Anuidade, Saque com cartão no Brasil, Saque com cartão no exterior, Avaliação emergencial de crédito, Emissão segunda via, Tarifa pagamento de contas, SMS, OUTRA. [Restrição] Preenchimento obrigatório se Tipo de Transação selecionada for \'TARIFA\'
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountFee;
(function (EnumCreditCardAccountFee) {
    EnumCreditCardAccountFee["Anuidade"] = "ANUIDADE";
    EnumCreditCardAccountFee["SaqueCartaoBrasil"] = "SAQUE_CARTAO_BRASIL";
    EnumCreditCardAccountFee["SaqueCartaoExterior"] = "SAQUE_CARTAO_EXTERIOR";
    EnumCreditCardAccountFee["AvaliacaoEmergencialCredito"] = "AVALIACAO_EMERGENCIAL_CREDITO";
    EnumCreditCardAccountFee["EmissaoSegundaVia"] = "EMISSAO_SEGUNDA_VIA";
    EnumCreditCardAccountFee["TarifaPagamentoContas"] = "TARIFA_PAGAMENTO_CONTAS";
    EnumCreditCardAccountFee["Sms"] = "SMS";
    EnumCreditCardAccountFee["Outra"] = "OUTRA";
})(EnumCreditCardAccountFee = exports.EnumCreditCardAccountFee || (exports.EnumCreditCardAccountFee = {}));
/**
 * Categoria de Bandeiras de Cartões de Crédito (Instituidor do arranjo de pagamento). Bandeira é a detentora de todos os direitos e deveres da utilização da marca estampada no cartão, inclusive as bandeiras pertencentes aos emissores.
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountNetwork;
(function (EnumCreditCardAccountNetwork) {
    EnumCreditCardAccountNetwork["Visa"] = "VISA";
    EnumCreditCardAccountNetwork["Mastercard"] = "MASTERCARD";
    EnumCreditCardAccountNetwork["AmericanExpress"] = "AMERICAN_EXPRESS";
    EnumCreditCardAccountNetwork["DinersClub"] = "DINERS_CLUB";
    EnumCreditCardAccountNetwork["Hipercard"] = "HIPERCARD";
    EnumCreditCardAccountNetwork["BandeiraPropria"] = "BANDEIRA_PROPRIA";
    EnumCreditCardAccountNetwork["ChequeEletronico"] = "CHEQUE_ELETRONICO";
    EnumCreditCardAccountNetwork["Elo"] = "ELO";
    EnumCreditCardAccountNetwork["Outras"] = "OUTRAS";
})(EnumCreditCardAccountNetwork = exports.EnumCreditCardAccountNetwork || (exports.EnumCreditCardAccountNetwork = {}));
/**
 * Traz os tipos dos valores relativos aos pagamentos da fatura da conta de pagamento pós-paga: (Vide Enum)  - Valor de pagamento da fatura com parcelamento  - Valor pagamento da fatura realizado  - Outro Valor pago na fatura
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsBillingValueType;
(function (EnumCreditCardAccountsBillingValueType) {
    EnumCreditCardAccountsBillingValueType["ValorPagamentoFaturaParcelado"] = "VALOR_PAGAMENTO_FATURA_PARCELADO";
    EnumCreditCardAccountsBillingValueType["ValorPagamentoFaturaRealizado"] = "VALOR_PAGAMENTO_FATURA_REALIZADO";
    EnumCreditCardAccountsBillingValueType["OutroValorPagoFatura"] = "OUTRO_VALOR_PAGO_FATURA";
})(EnumCreditCardAccountsBillingValueType = exports.EnumCreditCardAccountsBillingValueType || (exports.EnumCreditCardAccountsBillingValueType = {}));
/**
 * Indicador que permite informar se o valor do limite é consolidado ou individual.
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsConsolidationType;
(function (EnumCreditCardAccountsConsolidationType) {
    EnumCreditCardAccountsConsolidationType["Consolidado"] = "CONSOLIDADO";
    EnumCreditCardAccountsConsolidationType["Individual"] = "INDIVIDUAL";
})(EnumCreditCardAccountsConsolidationType = exports.EnumCreditCardAccountsConsolidationType || (exports.EnumCreditCardAccountsConsolidationType = {}));
/**
 * Traz a denominação dos Encargos que incidem na fatura da conta de pagamento pós-paga. (Vide Enum) - Juros remuneratórios por atraso no pagamento da fatura - Multa por atraso no pagamento da fatura - Juros de mora por atraso no pagamento da fatura - IOF - Sem Encargo - Outros
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsFinanceChargeType;
(function (EnumCreditCardAccountsFinanceChargeType) {
    EnumCreditCardAccountsFinanceChargeType["JurosRemuneratoriosAtrasoPagamentoFatura"] = "JUROS_REMUNERATORIOS_ATRASO_PAGAMENTO_FATURA";
    EnumCreditCardAccountsFinanceChargeType["MultaAtrasoPagamentoFatura"] = "MULTA_ATRASO_PAGAMENTO_FATURA";
    EnumCreditCardAccountsFinanceChargeType["JurosMoraAtrasoPagamentoFatura"] = "JUROS_MORA_ATRASO_PAGAMENTO_FATURA";
    EnumCreditCardAccountsFinanceChargeType["Iof"] = "IOF";
    EnumCreditCardAccountsFinanceChargeType["SemEncargo"] = "SEM_ENCARGO";
    EnumCreditCardAccountsFinanceChargeType["Outros"] = "OUTROS";
})(EnumCreditCardAccountsFinanceChargeType = exports.EnumCreditCardAccountsFinanceChargeType || (exports.EnumCreditCardAccountsFinanceChargeType = {}));
/**
 * Indicador do tipo de limite
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsLineLimitType;
(function (EnumCreditCardAccountsLineLimitType) {
    EnumCreditCardAccountsLineLimitType["Total"] = "LIMITE_CREDITO_TOTAL";
    EnumCreditCardAccountsLineLimitType["ModalidadeOperacao"] = "LIMITE_CREDITO_MODALIDADE_OPERACAO";
})(EnumCreditCardAccountsLineLimitType = exports.EnumCreditCardAccountsLineLimitType || (exports.EnumCreditCardAccountsLineLimitType = {}));
/**
 *
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsLineName;
(function (EnumCreditCardAccountsLineName) {
    EnumCreditCardAccountsLineName["CreditoAVista"] = "CREDITO_A_VISTA";
    EnumCreditCardAccountsLineName["CreditoParcelado"] = "CREDITO_PARCELADO";
    EnumCreditCardAccountsLineName["SaqueCreditoBrasil"] = "SAQUE_CREDITO_BRASIL";
    EnumCreditCardAccountsLineName["SaqueCreditoExterior"] = "SAQUE_CREDITO_EXTERIOR";
    EnumCreditCardAccountsLineName["EmprestimoCartaoConsignado"] = "EMPRESTIMO_CARTAO_CONSIGNADO";
    EnumCreditCardAccountsLineName["Outros"] = "OUTROS";
})(EnumCreditCardAccountsLineName = exports.EnumCreditCardAccountsLineName || (exports.EnumCreditCardAccountsLineName = {}));
/**
 * Traz outros tipos de crédito contratados no cartão. [Restrição] Preenchimento obrigatório se o tipo transação selecionado for \'OPERACOES_CREDITO_CONTRATADAS_CARTAO\'
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsOtherCreditType;
(function (EnumCreditCardAccountsOtherCreditType) {
    EnumCreditCardAccountsOtherCreditType["CreditoRotativo"] = "CREDITO_ROTATIVO";
    EnumCreditCardAccountsOtherCreditType["ParcelamentoFatura"] = "PARCELAMENTO_FATURA";
    EnumCreditCardAccountsOtherCreditType["Emprestimo"] = "EMPRESTIMO";
    EnumCreditCardAccountsOtherCreditType["Outros"] = "OUTROS";
})(EnumCreditCardAccountsOtherCreditType = exports.EnumCreditCardAccountsOtherCreditType || (exports.EnumCreditCardAccountsOtherCreditType = {}));
/**
 * Traz as formas de efetivação do pagamento realizado: (Vide Enum) - Débito em conta corrente - Boleto bancário - Averbação em folha - PIX
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsPaymentMode;
(function (EnumCreditCardAccountsPaymentMode) {
    EnumCreditCardAccountsPaymentMode["DebitoContaCorrente"] = "DEBITO_CONTA_CORRENTE";
    EnumCreditCardAccountsPaymentMode["BoletoBancario"] = "BOLETO_BANCARIO";
    EnumCreditCardAccountsPaymentMode["AverbacaoFolha"] = "AVERBACAO_FOLHA";
    EnumCreditCardAccountsPaymentMode["Pix"] = "PIX";
})(EnumCreditCardAccountsPaymentMode = exports.EnumCreditCardAccountsPaymentMode || (exports.EnumCreditCardAccountsPaymentMode = {}));
/**
 * Traz os tipos de pagamento. Preenchimento obrigatório se selecionado tipo de transação PAGAMENTO.
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsPaymentType;
(function (EnumCreditCardAccountsPaymentType) {
    EnumCreditCardAccountsPaymentType["Vista"] = "A_VISTA";
    EnumCreditCardAccountsPaymentType["Prazo"] = "A_PRAZO";
})(EnumCreditCardAccountsPaymentType = exports.EnumCreditCardAccountsPaymentType || (exports.EnumCreditCardAccountsPaymentType = {}));
/**
 * Categoria atribuída a um cartão de pagamento, sob uma certa denominação, que lhe agrega um conjunto de vantagens, diferenciando-o de acordo com o perfil do portador.
 * @export
 * @enum {string}
 */
var EnumCreditCardAccountsProductType;
(function (EnumCreditCardAccountsProductType) {
    EnumCreditCardAccountsProductType["ClassicNacional"] = "CLASSIC_NACIONAL";
    EnumCreditCardAccountsProductType["ClassicInternacional"] = "CLASSIC_INTERNACIONAL";
    EnumCreditCardAccountsProductType["Gold"] = "GOLD";
    EnumCreditCardAccountsProductType["Platinum"] = "PLATINUM";
    EnumCreditCardAccountsProductType["Infinite"] = "INFINITE";
    EnumCreditCardAccountsProductType["Electron"] = "ELECTRON";
    EnumCreditCardAccountsProductType["StandardNacional"] = "STANDARD_NACIONAL";
    EnumCreditCardAccountsProductType["StandardInternacional"] = "STANDARD_INTERNACIONAL";
    EnumCreditCardAccountsProductType["Eletronic"] = "ELETRONIC";
    EnumCreditCardAccountsProductType["Black"] = "BLACK";
    EnumCreditCardAccountsProductType["Redeshop"] = "REDESHOP";
    EnumCreditCardAccountsProductType["MaestroMastercardMaestro"] = "MAESTRO_MASTERCARD_MAESTRO";
    EnumCreditCardAccountsProductType["Green"] = "GREEN";
    EnumCreditCardAccountsProductType["Blue"] = "BLUE";
    EnumCreditCardAccountsProductType["Bluebox"] = "BLUEBOX";
    EnumCreditCardAccountsProductType["ProfissionalLiberal"] = "PROFISSIONAL_LIBERAL";
    EnumCreditCardAccountsProductType["ChequeEletronico"] = "CHEQUE_ELETRONICO";
    EnumCreditCardAccountsProductType["Corporativo"] = "CORPORATIVO";
    EnumCreditCardAccountsProductType["Empresarial"] = "EMPRESARIAL";
    EnumCreditCardAccountsProductType["Compras"] = "COMPRAS";
    EnumCreditCardAccountsProductType["BasicoNacional"] = "BASICO_NACIONAL";
    EnumCreditCardAccountsProductType["BasicoInternacional"] = "BASICO_INTERNACIONAL";
    EnumCreditCardAccountsProductType["Nanquim"] = "NANQUIM";
    EnumCreditCardAccountsProductType["Grafite"] = "GRAFITE";
    EnumCreditCardAccountsProductType["Mais"] = "MAIS";
    EnumCreditCardAccountsProductType["Outros"] = "OUTROS";
})(EnumCreditCardAccountsProductType = exports.EnumCreditCardAccountsProductType || (exports.EnumCreditCardAccountsProductType = {}));
/**
 * Traz os tipos de Transação
 * @export
 * @enum {string}
 */
var EnumCreditCardTransactionType;
(function (EnumCreditCardTransactionType) {
    EnumCreditCardTransactionType["Pagamento"] = "PAGAMENTO";
    EnumCreditCardTransactionType["Tarifa"] = "TARIFA";
    EnumCreditCardTransactionType["OperacoesCreditoContratadasCartao"] = "OPERACOES_CREDITO_CONTRATADAS_CARTAO";
    EnumCreditCardTransactionType["Estorno"] = "ESTORNO";
    EnumCreditCardTransactionType["Cashback"] = "CASHBACK";
    EnumCreditCardTransactionType["Outros"] = "OUTROS";
})(EnumCreditCardTransactionType = exports.EnumCreditCardTransactionType || (exports.EnumCreditCardTransactionType = {}));
/**
 * Indicador do tipo de lançamento: Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente. Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
 * @export
 * @enum {string}
 */
var EnumCreditDebitIndicator;
(function (EnumCreditDebitIndicator) {
    EnumCreditDebitIndicator["Credito"] = "CREDITO";
    EnumCreditDebitIndicator["Debito"] = "DEBITO";
})(EnumCreditDebitIndicator = exports.EnumCreditDebitIndicator || (exports.EnumCreditDebitIndicator = {}));
/**
 * Indicador do tipo de lançamento: Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente. Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
 * @export
 * @enum {string}
 */
var EnumCreditDebitIndicator1;
(function (EnumCreditDebitIndicator1) {
    EnumCreditDebitIndicator1["Credito"] = "CREDITO";
    EnumCreditDebitIndicator1["Debito"] = "DEBITO";
})(EnumCreditDebitIndicator1 = exports.EnumCreditDebitIndicator1 || (exports.EnumCreditDebitIndicator1 = {}));
/**
 * Identificação do Tipo de Pessoa da pessoa envolvida na transação. Pessoa Natural - Informar CPF no campo “payerCnpjCpf” Pessoa Jurídica - Informar CNPJ no campo “payerCnpjCpf”
 * @export
 * @enum {string}
 */
var EnumPartiePersonType;
(function (EnumPartiePersonType) {
    EnumPartiePersonType["Natural"] = "PESSOA_NATURAL";
    EnumPartiePersonType["Juridica"] = "PESSOA_JURIDICA";
})(EnumPartiePersonType = exports.EnumPartiePersonType || (exports.EnumPartiePersonType = {}));
/**
 * Tipo de Transação
 * @export
 * @enum {string}
 */
var EnumTransactionTypes;
(function (EnumTransactionTypes) {
    EnumTransactionTypes["Ted"] = "TED";
    EnumTransactionTypes["Doc"] = "DOC";
    EnumTransactionTypes["Pix"] = "PIX";
    EnumTransactionTypes["TransferenciaMesmaInstituicao"] = "TRANSFERENCIA_MESMA_INSTITUICAO";
    EnumTransactionTypes["Boleto"] = "BOLETO";
    EnumTransactionTypes["ConvenioArrecadacao"] = "CONVENIO_ARRECADACAO";
    EnumTransactionTypes["PacoteTarifaServicos"] = "PACOTE_TARIFA_SERVICOS";
    EnumTransactionTypes["TarifaServicosAvulsos"] = "TARIFA_SERVICOS_AVULSOS";
    EnumTransactionTypes["FolhaPagamento"] = "FOLHA_PAGAMENTO";
    EnumTransactionTypes["Deposito"] = "DEPOSITO";
    EnumTransactionTypes["Saque"] = "SAQUE";
    EnumTransactionTypes["Cartao"] = "CARTAO";
    EnumTransactionTypes["EncargosJurosChequeEspecial"] = "ENCARGOS_JUROS_CHEQUE_ESPECIAL";
    EnumTransactionTypes["RendimentoAplicFinanceira"] = "RENDIMENTO_APLIC_FINANCEIRA";
    EnumTransactionTypes["PortabilidadeSalario"] = "PORTABILIDADE_SALARIO";
    EnumTransactionTypes["ResgateAplicFinanceira"] = "RESGATE_APLIC_FINANCEIRA";
    EnumTransactionTypes["OperacaoCredito"] = "OPERACAO_CREDITO";
    EnumTransactionTypes["Outros"] = "OUTROS";
})(EnumTransactionTypes = exports.EnumTransactionTypes || (exports.EnumTransactionTypes = {}));
/**
    * @export
    * @enum {string}
    */
var ResponseConsentDataStatusEnum;
(function (ResponseConsentDataStatusEnum) {
    ResponseConsentDataStatusEnum["Authorised"] = "AUTHORISED";
    ResponseConsentDataStatusEnum["AwaitingAuthorisation"] = "AWAITING_AUTHORISATION";
    ResponseConsentDataStatusEnum["Rejected"] = "REJECTED";
})(ResponseConsentDataStatusEnum = exports.ResponseConsentDataStatusEnum || (exports.ResponseConsentDataStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ResponseConsentDataPermissionsEnum;
(function (ResponseConsentDataPermissionsEnum) {
    ResponseConsentDataPermissionsEnum["AccountsRead"] = "ACCOUNTS_READ";
    ResponseConsentDataPermissionsEnum["AccountsBalancesRead"] = "ACCOUNTS_BALANCES_READ";
    ResponseConsentDataPermissionsEnum["AccountsTransactionsRead"] = "ACCOUNTS_TRANSACTIONS_READ";
    ResponseConsentDataPermissionsEnum["AccountsOverdraftLimitsRead"] = "ACCOUNTS_OVERDRAFT_LIMITS_READ";
    ResponseConsentDataPermissionsEnum["CreditCardsAccountsRead"] = "CREDIT_CARDS_ACCOUNTS_READ";
    ResponseConsentDataPermissionsEnum["CreditCardsAccountsBillsRead"] = "CREDIT_CARDS_ACCOUNTS_BILLS_READ";
    ResponseConsentDataPermissionsEnum["CreditCardsAccountsBillsTransactionsRead"] = "CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ";
    ResponseConsentDataPermissionsEnum["CreditCardsAccountsLimitsRead"] = "CREDIT_CARDS_ACCOUNTS_LIMITS_READ";
    ResponseConsentDataPermissionsEnum["CreditCardsAccountsTransactionsRead"] = "CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ";
    ResponseConsentDataPermissionsEnum["CustomersPersonalIdentificationsRead"] = "CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ";
    ResponseConsentDataPermissionsEnum["CustomersPersonalAdittionalinfoRead"] = "CUSTOMERS_PERSONAL_ADITTIONALINFO_READ";
    ResponseConsentDataPermissionsEnum["CustomersBusinessIdentificationsRead"] = "CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ";
    ResponseConsentDataPermissionsEnum["CustomersBusinessAdittionalinfoRead"] = "CUSTOMERS_BUSINESS_ADITTIONALINFO_READ";
    ResponseConsentDataPermissionsEnum["FinancingsRead"] = "FINANCINGS_READ";
    ResponseConsentDataPermissionsEnum["FinancingsScheduledInstalmentsRead"] = "FINANCINGS_SCHEDULED_INSTALMENTS_READ";
    ResponseConsentDataPermissionsEnum["FinancingsPaymentsRead"] = "FINANCINGS_PAYMENTS_READ";
    ResponseConsentDataPermissionsEnum["FinancingsWarrantiesRead"] = "FINANCINGS_WARRANTIES_READ";
    ResponseConsentDataPermissionsEnum["InvoiceFinancingsRead"] = "INVOICE_FINANCINGS_READ";
    ResponseConsentDataPermissionsEnum["InvoiceFinancingsScheduledInstalmentsRead"] = "INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ";
    ResponseConsentDataPermissionsEnum["InvoiceFinancingsPaymentsRead"] = "INVOICE_FINANCINGS_PAYMENTS_READ";
    ResponseConsentDataPermissionsEnum["InvoiceFinancingsWarrantiesRead"] = "INVOICE_FINANCINGS_WARRANTIES_READ";
    ResponseConsentDataPermissionsEnum["LoansRead"] = "LOANS_READ";
    ResponseConsentDataPermissionsEnum["LoansScheduledInstalmentsRead"] = "LOANS_SCHEDULED_INSTALMENTS_READ";
    ResponseConsentDataPermissionsEnum["LoansPaymentsRead"] = "LOANS_PAYMENTS_READ";
    ResponseConsentDataPermissionsEnum["LoansWarrantiesRead"] = "LOANS_WARRANTIES_READ";
    ResponseConsentDataPermissionsEnum["UnarrangedAccountsOverdraftRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_READ";
    ResponseConsentDataPermissionsEnum["UnarrangedAccountsOverdraftScheduledInstalmentsRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ";
    ResponseConsentDataPermissionsEnum["UnarrangedAccountsOverdraftPaymentsRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ";
    ResponseConsentDataPermissionsEnum["UnarrangedAccountsOverdraftWarrantiesRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ";
    ResponseConsentDataPermissionsEnum["ResourcesRead"] = "RESOURCES_READ";
})(ResponseConsentDataPermissionsEnum = exports.ResponseConsentDataPermissionsEnum || (exports.ResponseConsentDataPermissionsEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ResponseConsentFullDataStatusEnum;
(function (ResponseConsentFullDataStatusEnum) {
    ResponseConsentFullDataStatusEnum["Authorised"] = "AUTHORISED";
    ResponseConsentFullDataStatusEnum["AwaitingAuthorisation"] = "AWAITING_AUTHORISATION";
    ResponseConsentFullDataStatusEnum["Rejected"] = "REJECTED";
})(ResponseConsentFullDataStatusEnum = exports.ResponseConsentFullDataStatusEnum || (exports.ResponseConsentFullDataStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ResponseConsentFullDataPermissionsEnum;
(function (ResponseConsentFullDataPermissionsEnum) {
    ResponseConsentFullDataPermissionsEnum["AccountsRead"] = "ACCOUNTS_READ";
    ResponseConsentFullDataPermissionsEnum["AccountsBalancesRead"] = "ACCOUNTS_BALANCES_READ";
    ResponseConsentFullDataPermissionsEnum["AccountsTransactionsRead"] = "ACCOUNTS_TRANSACTIONS_READ";
    ResponseConsentFullDataPermissionsEnum["AccountsOverdraftLimitsRead"] = "ACCOUNTS_OVERDRAFT_LIMITS_READ";
    ResponseConsentFullDataPermissionsEnum["CreditCardsAccountsRead"] = "CREDIT_CARDS_ACCOUNTS_READ";
    ResponseConsentFullDataPermissionsEnum["CreditCardsAccountsBillsRead"] = "CREDIT_CARDS_ACCOUNTS_BILLS_READ";
    ResponseConsentFullDataPermissionsEnum["CreditCardsAccountsBillsTransactionsRead"] = "CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ";
    ResponseConsentFullDataPermissionsEnum["CreditCardsAccountsLimitsRead"] = "CREDIT_CARDS_ACCOUNTS_LIMITS_READ";
    ResponseConsentFullDataPermissionsEnum["CreditCardsAccountsTransactionsRead"] = "CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ";
    ResponseConsentFullDataPermissionsEnum["CustomersPersonalIdentificationsRead"] = "CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ";
    ResponseConsentFullDataPermissionsEnum["CustomersPersonalAdittionalinfoRead"] = "CUSTOMERS_PERSONAL_ADITTIONALINFO_READ";
    ResponseConsentFullDataPermissionsEnum["CustomersBusinessIdentificationsRead"] = "CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ";
    ResponseConsentFullDataPermissionsEnum["CustomersBusinessAdittionalinfoRead"] = "CUSTOMERS_BUSINESS_ADITTIONALINFO_READ";
    ResponseConsentFullDataPermissionsEnum["FinancingsRead"] = "FINANCINGS_READ";
    ResponseConsentFullDataPermissionsEnum["FinancingsScheduledInstalmentsRead"] = "FINANCINGS_SCHEDULED_INSTALMENTS_READ";
    ResponseConsentFullDataPermissionsEnum["FinancingsPaymentsRead"] = "FINANCINGS_PAYMENTS_READ";
    ResponseConsentFullDataPermissionsEnum["FinancingsWarrantiesRead"] = "FINANCINGS_WARRANTIES_READ";
    ResponseConsentFullDataPermissionsEnum["InvoiceFinancingsRead"] = "INVOICE_FINANCINGS_READ";
    ResponseConsentFullDataPermissionsEnum["InvoiceFinancingsScheduledInstalmentsRead"] = "INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ";
    ResponseConsentFullDataPermissionsEnum["InvoiceFinancingsPaymentsRead"] = "INVOICE_FINANCINGS_PAYMENTS_READ";
    ResponseConsentFullDataPermissionsEnum["InvoiceFinancingsWarrantiesRead"] = "INVOICE_FINANCINGS_WARRANTIES_READ";
    ResponseConsentFullDataPermissionsEnum["LoansRead"] = "LOANS_READ";
    ResponseConsentFullDataPermissionsEnum["LoansScheduledInstalmentsRead"] = "LOANS_SCHEDULED_INSTALMENTS_READ";
    ResponseConsentFullDataPermissionsEnum["LoansPaymentsRead"] = "LOANS_PAYMENTS_READ";
    ResponseConsentFullDataPermissionsEnum["LoansWarrantiesRead"] = "LOANS_WARRANTIES_READ";
    ResponseConsentFullDataPermissionsEnum["UnarrangedAccountsOverdraftRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_READ";
    ResponseConsentFullDataPermissionsEnum["UnarrangedAccountsOverdraftScheduledInstalmentsRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ";
    ResponseConsentFullDataPermissionsEnum["UnarrangedAccountsOverdraftPaymentsRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ";
    ResponseConsentFullDataPermissionsEnum["UnarrangedAccountsOverdraftWarrantiesRead"] = "UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ";
    ResponseConsentFullDataPermissionsEnum["ResourcesRead"] = "RESOURCES_READ";
})(ResponseConsentFullDataPermissionsEnum = exports.ResponseConsentFullDataPermissionsEnum || (exports.ResponseConsentFullDataPermissionsEnum = {}));
/**
    * @export
    * @enum {string}
    */
var UpdateConsentDataStatusEnum;
(function (UpdateConsentDataStatusEnum) {
    UpdateConsentDataStatusEnum["Authorised"] = "AUTHORISED";
    UpdateConsentDataStatusEnum["AwaitingAuthorisation"] = "AWAITING_AUTHORISATION";
    UpdateConsentDataStatusEnum["Rejected"] = "REJECTED";
})(UpdateConsentDataStatusEnum = exports.UpdateConsentDataStatusEnum || (exports.UpdateConsentDataStatusEnum = {}));
/**
 * AccountsApi - axios parameter creator
 * @export
 */
exports.AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: (authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getAccounts', 'authorization', authorization);
            const localVarPath = `/accounts/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }
            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountId: (authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getAccountsAccountId', 'authorization', authorization);
            // verify required parameter 'accountId' is not null or undefined
            common_1.assertParamExists('getAccountsAccountId', 'accountId', accountId);
            const localVarPath = `/accounts/v1/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdBalances: (authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getAccountsAccountIdBalances', 'authorization', authorization);
            // verify required parameter 'accountId' is not null or undefined
            common_1.assertParamExists('getAccountsAccountIdBalances', 'accountId', accountId);
            const localVarPath = `/accounts/v1/accounts/{accountId}/balances`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdOverdraftLimits: (authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getAccountsAccountIdOverdraftLimits', 'authorization', authorization);
            // verify required parameter 'accountId' is not null or undefined
            common_1.assertParamExists('getAccountsAccountIdOverdraftLimits', 'accountId', accountId);
            const localVarPath = `/accounts/v1/accounts/{accountId}/overdraft-limits`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdTransactions: (authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getAccountsAccountIdTransactions', 'authorization', authorization);
            // verify required parameter 'accountId' is not null or undefined
            common_1.assertParamExists('getAccountsAccountIdTransactions', 'accountId', accountId);
            const localVarPath = `/accounts/v1/accounts/{accountId}/transactions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }
            if (fromBookingDate !== undefined) {
                localVarQueryParameter['fromBookingDate'] = (fromBookingDate instanceof Date) ?
                    fromBookingDate.toISOString().substr(0, 10) :
                    fromBookingDate;
            }
            if (toBookingDate !== undefined) {
                localVarQueryParameter['toBookingDate'] = (toBookingDate instanceof Date) ?
                    toBookingDate.toISOString().substr(0, 10) :
                    toBookingDate;
            }
            if (creditDebitIndicator !== undefined) {
                localVarQueryParameter['creditDebitIndicator'] = creditDebitIndicator;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AccountsApi - functional programming interface
 * @export
 */
exports.AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.AccountsApiAxiosParamCreator(configuration);
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * AccountsApi - factory interface
 * @export
 */
exports.AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.AccountsApiFp(configuration);
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options) {
            return localVarFp.getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options) {
            return localVarFp.getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
     * @summary Obtém a lista de contas consentidas pelo cliente.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options) {
        return exports.AccountsApiFp(this.configuration).getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.AccountsApiFp(this.configuration).getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os saldos da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.AccountsApiFp(this.configuration).getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os limites da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.AccountsApiFp(this.configuration).getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de transações da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromBookingDate] Data inicial de filtragem.
     * @param {string} [toBookingDate] Data final de filtragem.
     * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options) {
        return exports.AccountsApiFp(this.configuration).getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * ConsentsApi - axios parameter creator
 * @export
 */
exports.ConsentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsDeleteConsentsConsentId: (consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'consentId' is not null or undefined
            common_1.assertParamExists('consentsDeleteConsentsConsentId', 'consentId', consentId);
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('consentsDeleteConsentsConsentId', 'authorization', authorization);
            const localVarPath = `/consents/v1/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", ["consents"], configuration);
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsGetConsentsConsentId: (consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'consentId' is not null or undefined
            common_1.assertParamExists('consentsGetConsentsConsentId', 'consentId', consentId);
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('consentsGetConsentsConsentId', 'authorization', authorization);
            const localVarPath = `/consents/v1/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", ["consents"], configuration);
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPostConsents: (authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('consentsPostConsents', 'authorization', authorization);
            // verify required parameter 'createConsent' is not null or undefined
            common_1.assertParamExists('consentsPostConsents', 'createConsent', createConsent);
            const localVarPath = `/consents/v1/consents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", ["consents"], configuration);
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createConsent, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPutConsents: (consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'consentId' is not null or undefined
            common_1.assertParamExists('consentsPutConsents', 'consentId', consentId);
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('consentsPutConsents', 'authorization', authorization);
            // verify required parameter 'updateConsent' is not null or undefined
            common_1.assertParamExists('consentsPutConsents', 'updateConsent', updateConsent);
            const localVarPath = `/consents/v1/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", ["consents"], configuration);
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(updateConsent, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ConsentsApi - functional programming interface
 * @export
 */
exports.ConsentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ConsentsApiAxiosParamCreator(configuration);
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ConsentsApi - factory interface
 * @export
 */
exports.ConsentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ConsentsApiFp(configuration);
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ConsentsApi - object-oriented interface
 * @export
 * @class ConsentsApi
 * @extends {BaseAPI}
 */
class ConsentsApi extends base_1.BaseAPI {
    /**
     * Método para deletar/revogar o consentimento identificado por consentId.
     * @summary Deletar/revogar o consentimento identificado por consentId.
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.ConsentsApiFp(this.configuration).consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter detalhes do consentimento identificado por consentId.
     * @summary Obter detalhes do consentimento identificado por consentId.
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.ConsentsApiFp(this.configuration).consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para a criação de um novo consentimento.
     * @summary Criar novo pedido de consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {CreateConsent} createConsent Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.ConsentsApiFp(this.configuration).consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para a criação de um novo consentimento.
     * @summary Update the consent API
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.ConsentsApiFp(this.configuration).consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConsentsApi = ConsentsApi;
/**
 * CreditCardApi - axios parameter creator
 * @export
 */
exports.CreditCardApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Método para obter a lista de contas de pagamento pós-paga mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
         * @summary Conjunto de informações das Contas de pagamento pós paga
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccounts: (authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccounts', 'authorization', authorization);
            const localVarPath = `/credit-cards-accounts/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os dados de identificação da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountId: (authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountId', 'authorization', authorization);
            // verify required parameter 'creditCardAccountId' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountId', 'creditCardAccountId', creditCardAccountId);
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter a lista de faturas da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de faturas da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromDueDate] Data inicial de filtragem.
         * @param {string} [toDueDate] Data final de filtragem.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBills: (authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdBills', 'authorization', authorization);
            // verify required parameter 'creditCardAccountId' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdBills', 'creditCardAccountId', creditCardAccountId);
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}/bills`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }
            if (fromDueDate !== undefined) {
                localVarQueryParameter['fromDueDate'] = (fromDueDate instanceof Date) ?
                    fromDueDate.toISOString().substr(0, 10) :
                    fromDueDate;
            }
            if (toDueDate !== undefined) {
                localVarQueryParameter['toDueDate'] = (toDueDate instanceof Date) ?
                    toDueDate.toISOString().substr(0, 10) :
                    toDueDate;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId e billId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId e billId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} billId Identificador da fatura.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions: (authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions', 'authorization', authorization);
            // verify required parameter 'creditCardAccountId' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions', 'creditCardAccountId', creditCardAccountId);
            // verify required parameter 'billId' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions', 'billId', billId);
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}/bills/{billId}/transactions`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)))
                .replace(`{${"billId"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }
            if (fromTransactionDate !== undefined) {
                localVarQueryParameter['fromTransactionDate'] = (fromTransactionDate instanceof Date) ?
                    fromTransactionDate.toISOString().substr(0, 10) :
                    fromTransactionDate;
            }
            if (toTransactionDate !== undefined) {
                localVarQueryParameter['toTransactionDate'] = (toTransactionDate instanceof Date) ?
                    toTransactionDate.toISOString().substr(0, 10) :
                    toTransactionDate;
            }
            if (transactionType !== undefined) {
                localVarQueryParameter['transactionType'] = transactionType;
            }
            if (payeeMCC !== undefined) {
                localVarQueryParameter['payeeMCC'] = payeeMCC;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os limites da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdLimits: (authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdLimits', 'authorization', authorization);
            // verify required parameter 'creditCardAccountId' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdLimits', 'creditCardAccountId', creditCardAccountId);
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}/limits`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdTransactions: (authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdTransactions', 'authorization', authorization);
            // verify required parameter 'creditCardAccountId' is not null or undefined
            common_1.assertParamExists('creditCardsGetAccountsCreditCardAccountIdTransactions', 'creditCardAccountId', creditCardAccountId);
            const localVarPath = `/credit-cards-accounts/v1/accounts/{creditCardAccountId}/transactions`
                .replace(`{${"creditCardAccountId"}}`, encodeURIComponent(String(creditCardAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication OAuth2Security required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }
            if (fromTransactionDate !== undefined) {
                localVarQueryParameter['fromTransactionDate'] = (fromTransactionDate instanceof Date) ?
                    fromTransactionDate.toISOString().substr(0, 10) :
                    fromTransactionDate;
            }
            if (toTransactionDate !== undefined) {
                localVarQueryParameter['toTransactionDate'] = (toTransactionDate instanceof Date) ?
                    toTransactionDate.toISOString().substr(0, 10) :
                    toTransactionDate;
            }
            if (transactionType !== undefined) {
                localVarQueryParameter['transactionType'] = transactionType;
            }
            if (payeeMCC !== undefined) {
                localVarQueryParameter['payeeMCC'] = payeeMCC;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CreditCardApi - functional programming interface
 * @export
 */
exports.CreditCardApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.CreditCardApiAxiosParamCreator(configuration);
    return {
        /**
         * Método para obter a lista de contas de pagamento pós-paga mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
         * @summary Conjunto de informações das Contas de pagamento pós paga
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os dados de identificação da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter a lista de faturas da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de faturas da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromDueDate] Data inicial de filtragem.
         * @param {string} [toDueDate] Data final de filtragem.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId e billId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId e billId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} billId Identificador da fatura.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os limites da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * CreditCardApi - factory interface
 * @export
 */
exports.CreditCardApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.CreditCardApiFp(configuration);
    return {
        /**
         * Método para obter a lista de contas de pagamento pós-paga mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
         * @summary Conjunto de informações das Contas de pagamento pós paga
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options) {
            return localVarFp.creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter a lista de faturas da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de faturas da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromDueDate] Data inicial de filtragem.
         * @param {string} [toDueDate] Data final de filtragem.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options) {
            return localVarFp.creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId e billId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId e billId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} billId Identificador da fatura.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options) {
            return localVarFp.creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os limites da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por creditCardAccountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromTransactionDate] Data inicial de filtragem.
         * @param {string} [toTransactionDate] Data final de filtragem.
         * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
         * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options) {
            return localVarFp.creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CreditCardApi - object-oriented interface
 * @export
 * @class CreditCardApi
 * @extends {BaseAPI}
 */
class CreditCardApi extends base_1.BaseAPI {
    /**
     * Método para obter a lista de contas de pagamento pós-paga mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
     * @summary Conjunto de informações das Contas de pagamento pós paga
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options) {
        return exports.CreditCardApiFp(this.configuration).creditCardsGetAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os dados de identificação da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por creditCardAccountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountId(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter a lista de faturas da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de faturas da conta identificada por creditCardAccountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromDueDate] Data inicial de filtragem.
     * @param {string} [toDueDate] Data final de filtragem.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options) {
        return exports.CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountIdBills(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromDueDate, toDueDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId e billId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de transações da conta identificada por creditCardAccountId e billId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} billId Identificador da fatura.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromTransactionDate] Data inicial de filtragem.
     * @param {string} [toTransactionDate] Data final de filtragem.
     * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
     * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options) {
        return exports.CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountIdBillsBillIdTransactions(authorization, creditCardAccountId, billId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os limites da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os limites da conta identificada por creditCardAccountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountIdLimits(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter a lista de transações da conta de pagamento pós-paga identificada por creditCardAccountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de transações da conta identificada por creditCardAccountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} creditCardAccountId Identifica de forma única a conta pagamento pós-paga do cliente, mantendo as regras de imutabilidade detro da instituição transmissora
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromTransactionDate] Data inicial de filtragem.
     * @param {string} [toTransactionDate] Data final de filtragem.
     * @param {EnumCreditCardTransactionType} [transactionType] Traz os tipos de Transação
     * @param {number} [payeeMCC] MCC é o Merchant Category Code, ou o código da categoria do estabelecimento comercial. Os MCCs são agrupados segundo suas similaridades
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditCardApi
     */
    creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options) {
        return exports.CreditCardApiFp(this.configuration).creditCardsGetAccountsCreditCardAccountIdTransactions(authorization, creditCardAccountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromTransactionDate, toTransactionDate, transactionType, payeeMCC, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CreditCardApi = CreditCardApi;
/**
 * OpenIDProviderApi - axios parameter creator
 * @export
 */
exports.OpenIDProviderApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backchannelPost: (xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/backchannel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAuthPost: (xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/device/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet: (xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdDelete: (clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            common_1.assertParamExists('regClientIdDelete', 'clientId', clientId);
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdGet: (clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            common_1.assertParamExists('regClientIdGet', 'clientId', clientId);
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdPut: (clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'clientId' is not null or undefined
            common_1.assertParamExists('regClientIdPut', 'clientId', clientId);
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regPost: (xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/reg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPost: (xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenIntrospectionPost: (xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/token/introspection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: (introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'introspectionRequest' is not null or undefined
            common_1.assertParamExists('tokenPost', 'introspectionRequest', introspectionRequest);
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(introspectionRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * OpenIDProviderApi - functional programming interface
 * @export
 */
exports.OpenIDProviderApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.OpenIDProviderApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * OpenIDProviderApi - factory interface
 * @export
 */
exports.OpenIDProviderApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.OpenIDProviderApiFp(configuration);
    return {
        /**
         *
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return localVarFp.backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return localVarFp.deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return localVarFp.regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return localVarFp.requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
            return localVarFp.tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OpenIDProviderApi - object-oriented interface
 * @export
 * @class OpenIDProviderApi
 * @extends {BaseAPI}
 */
class OpenIDProviderApi extends base_1.BaseAPI {
    /**
     *
     * @summary Post a Oauth 2.0 ciba request
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
        return exports.OpenIDProviderApiFp(this.configuration).backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post a request to the device endpoint to retrieve a token
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
        return exports.OpenIDProviderApiFp(this.configuration).deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets the user information stored in OpenId Provider
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.OpenIDProviderApiFp(this.configuration).meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an oauth client. Cascade delete all child details
     * @param {string} clientId The ClientId to be deleted
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.OpenIDProviderApiFp(this.configuration).regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an oauth client by Id
     * @param {string} clientId The oauth ClientId
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.OpenIDProviderApiFp(this.configuration).regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an oauth client by Id
     * @param {string} clientId The oauth ClientId
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.OpenIDProviderApiFp(this.configuration).regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a client
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
        return exports.OpenIDProviderApiFp(this.configuration).regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post a Oauth 2.0 pushed authorization request
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
        return exports.OpenIDProviderApiFp(this.configuration).requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options) {
        return exports.OpenIDProviderApiFp(this.configuration).tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post a request to the token endpoint to retrieve a token
     * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.OpenIDProviderApiFp(this.configuration).tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OpenIDProviderApi = OpenIDProviderApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
exports.UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccounts: (authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getUserAccounts', 'authorization', authorization);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserAccounts', 'userId', userId);
            const localVarPath = `/user/{userId}/accounts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditCardAccounts: (authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getUserCreditCardAccounts', 'authorization', authorization);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserCreditCardAccounts', 'userId', userId);
            const localVarPath = `/user/{userId}/credit-card-accounts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFinancings: (authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getUserFinancings', 'authorization', authorization);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserFinancings', 'userId', userId);
            const localVarPath = `/user/{userId}/financings`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInvoiceFinancings: (authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getUserInvoiceFinancings', 'authorization', authorization);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserInvoiceFinancings', 'userId', userId);
            const localVarPath = `/user/{userId}/invoice-financings`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLoans: (authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getUserLoans', 'authorization', authorization);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserLoans', 'userId', userId);
            const localVarPath = `/user/{userId}/loans`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUnarrangedAccountsOverdraft: (authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authorization' is not null or undefined
            common_1.assertParamExists('getUserUnarrangedAccountsOverdraft', 'authorization', authorization);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserUnarrangedAccountsOverdraft', 'userId', userId);
            const localVarPath = `/user/{userId}/unarranged-accounts-overdraft`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication authorizer required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }
            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }
            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }
            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */
exports.UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UsersApiAxiosParamCreator(configuration);
    return {
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * UsersApi - factory interface
 * @export
 */
exports.UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UsersApiFp(configuration);
    return {
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
            return localVarFp.getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.UsersApiFp(this.configuration).getUserAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.UsersApiFp(this.configuration).getUserCreditCardAccounts(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.UsersApiFp(this.configuration).getUserFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.UsersApiFp(this.configuration).getUserInvoiceFinancings(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.UsersApiFp(this.configuration).getUserLoans(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options) {
        return exports.UsersApiFp(this.configuration).getUserUnarrangedAccountsOverdraft(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
